<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
    <title>cicada-nymph.org</title>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="css/the-little-language-designer.css"/>
    <style type="text/css">
    <!--
      body {
        color: #f8f8f0;
        background-color: #1b1d1e;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #a6e22e;
      }
      .cicada-nymph-comment {
        /* cicada-nymph-comment-face */
        color: #FF8888;
      }
      .cicada-nymph-exit {
        /* cicada-nymph-exit-face */
        color: #00ffff;
        font-weight: bold;
      }
      .cicada-nymph-lexicographer {
        /* cicada-nymph-lexicographer-face */
        color: #ae81ff;
        font-weight: bold;
      }
      .cicada-nymph-number {
        /* cicada-nymph-number-face */
        color: #8b636c;
      }
      .cicada-nymph-sentence-reader {
        /* cicada-nymph-sentence-reader-face */
        color: #ffff00;
        font-weight: bold;
      }
      .cicada-nymph-syntax-key-word {
        /* cicada-nymph-syntax-key-word-face */
        color: #f92672;
        font-weight: bold;
      }
      .cicada-nymph-variable {
        /* cicada-nymph-variable-face */
        color: #fd971f;
      }
      .cicada-nymph-word-to-define {
        /* cicada-nymph-word-to-define-face */
        color: #ef5939;
        font-weight: bold;
      }
      .comment {
        /* font-lock-comment-face */
        color: #FF8888;
      }
      .constant {
        /* font-lock-constant-face */
        color: #ae81ff;
      }
      .default {
        /* default */
        color: #f8f8f0;
        background-color: #1b1d1e;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #a6e22e;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #f92672;
        font-weight: bold;
      }
      .org-block {
        /* org-block */
        color: #b3b3b3;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        color: #FF8888;
      }
      .org-block-end-line {
        /* org-block-end-line */
        color: #FF8888;
      }
      .org-document-info {
        /* org-document-info */
        color: #afeeee;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #b3b3b3;
      }
      .org-document-title {
        /* org-document-title */
        color: #afeeee;
        font-weight: bold;
      }
      .org-done {
        /* org-done */
        color: #98fb98;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #a6e22e;
      }
      .org-level-2 {
        /* org-level-2 */
        color: #fd971f;
      }
      .org-level-3 {
        /* org-level-3 */
        color: #f92672;
        font-weight: bold;
      }
      .org-table {
        /* org-table */
        color: #87cefa;
      }
      .org-todo {
        /* org-todo */
        color: #ffc0cb;
        font-weight: bold;
      }
      .preprocessor {
        /* font-lock-preprocessor-face */
        color: #a6e22e;
      }
      .return-stack-bar-ket {
        /* return-stack-bar-ket-face */
        color: #dc322f;
        font-weight: bold;
      }
      .return-stack-exit {
        /* return-stack-exit-face */
        color: #00ffff;
        font-weight: bold;
      }
      .return-stack-jo {
        /* return-stack-jo-face */
        color: #ef5939;
        font-weight: bold;
      }
      .return-stack-line {
        /* return-stack-line-face */
        color: #ae81ff;
        font-weight: bold;
      }
      .return-stack-the-jo {
        /* return-stack-the-jo-face */
        color: #fd971f;
        font-weight: bold;
      }
      .string {
        /* font-lock-string-face */
        color: #e6db74;
      }
      .type {
        /* font-lock-type-face */
        color: #66d9ef;
        font-weight: bold;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #fd971f;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="org-document-info-keyword">#+TITLE:</span>  <span class="org-document-title">cicada-nymph
</span><span class="org-document-info-keyword">#+AUTHOR:</span> <span class="org-document-info">&#35613;&#23431;&#24646; / XIE Yuheng
</span><span class="org-document-info-keyword">#+EMAIL:</span>  <span class="org-document-info">xyheme@gmail.com
</span>
<span class="org-level-1">* </span><span class="org-done">todo</span>
<span class="org-level-2">** more documentations on the nature of the language and the interpreter</span>
<span class="org-level-2">** use the exception handling system to do a better "define-function"</span>
<span class="org-level-2">** more debug functions</span>
<span class="org-level-2">** "if &amp; else &amp; then" in cicada-nymph itself</span>
<span class="org-level-2">** [maybe] little-tester</span>
<span class="org-level-1">* ===================================</span>
<span class="org-level-1">* </span><span class="org-todo">note</span>
<span class="org-level-2">** jo &amp; jojo</span>
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "&#29664;&#29664;" in Chinese]
<span class="org-level-2">** threaded-code interpreter</span>
   * the dictionary is a single-linked-list
     of word-jo-jojo
   * a jojo is an vector of jo
   * from a jo one can find a jojo
     for example
     this is what the "explain$function" will do
     to help the interpreter
     to explain the mean of a jo
   * from a word one can find a jo
     for example
     this is what the "define-function" will do
     from source code
     it defines new function into dictionary
     by creating new structured data into memory
<span class="org-level-2">** the order of development</span>
   * indirect-threaded-code interpreter
     1. macro about argument_stack &amp; return_stack
     2. macro about jo &amp; jojo
     3. macro about next
     4. the way to do memory allocation
     5. begin_to_interpret_threaded_code
     6. little_test
     7. special primitive function
   * basic-REPL as postfix-notation function executer
     1. write-byte &amp; read-byte
     2. read-word &amp; write-string
     3. string-&gt;integer &amp; find &amp; execute-word &amp; basic-REPL
   * define &amp; make things into memory
     1. ":" and ";" are used to read a string of words for compiler
        [looks like bar-ket but special]
     2. "&lt;&lt; &gt;&gt;" as the only way todo comment
<span class="org-level-2">** different from the re-designed cicada-language</span>
   * simplifications are for teaching purpose only
   * first and foremost
     function programming will NOT be supported will in this implementation
   * a helper function must be defined before it is used
   * no mixfix-notation
     * function call is "function" instead of "(function)"
     * no such thing like
       1 2 (add) = 1 (add 2) = (add 1 2)
   * no named local argument
     * thus no inited local argument
   * no title-name-table
     * and single name space
   * no type
     * no type inference
     * no dynamic type tag
     * no static type declaration
   * global linked-list for naming
     * not hash-table
     * in classical forth
       the linked-list of jo is called dictionary
   * no dynamic-memory-management
     * no garbage-collectior
   * about comment
     * the comment of the argument &amp; return value of function
       is allowed to be written in free style normal comment
<span class="org-level-2">** convention</span>
<span class="org-level-3">*** naming convention</span>
    * a predicate of a type
      which denotes a subtype of that type
      uses that type as postfix
      such as
      "space-char?"
    * a function of a type
      uses that type as prefix
      such as
      "string-reverse"
      "string-equal?"
    * side-effect of structured data is postfixed by "!"
<span class="org-level-3">*** convention in assembly code</span>
    * using underline to compose big word from small words
    * using "$" as prefix and postfix separator
    * indentation level = 3
    * naming convention of jo
      <span class="org-table">| convention   | jo type  |</span>
      <span class="org-table">|--------------+----------|</span>
      <span class="org-table">| prefix "V__" | variable |</span>
      <span class="org-table">| prefix "M__" | macro    |</span>
    * but I use
      1. "zero" instead of "V__zero"
      2. "true" instead of "V__true"
<span class="org-level-3">*** convention in cicada-nymph code</span>
    * using dash to compose big word from small words
    * using "," as prefix and postfix separator
    * indentation style = free
    * words are separated by space
      except for bar-ket
      every bar-ket is viewed as a word
<span class="org-level-3">*** syntax of cicada-nymph</span>
    * syntax &amp;  semantic
      <span class="org-table">| syntax          | semantic                |</span>
      <span class="org-table">|-----------------+-------------------------|</span>
      <span class="org-table">| borderfix "* *" | variable                |</span>
      <span class="org-table">| borderfix "+ +" | [maybe use]             |</span>
      <span class="org-table">| bar-ket ( )     | not use                 |</span>
      <span class="org-table">| bar-ket [ ]     | not use                 |</span>
      <span class="org-table">| bar-ket { }     | macro call              |</span>
      <span class="org-table">|                 | (for macros of which    |</span>
      <span class="org-table">|                 | the number of           |</span>
      <span class="org-table">|                 | arguments is not fix)   |</span>
      <span class="org-table">| prefix "!"      | exception               |</span>
      <span class="org-table">| postfix "!"     | some of the side-effect |</span>
      <span class="org-table">| postfix "?"     | predicate               |</span>
    * but I use
      1. "true" instead of "<span class="bold">*true*</span>"
      2. "false" instead of "<span class="bold">*false*</span>"
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* prolog</span>
<span class="org-level-2">** include linux header</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">include</span> <span class="string">"include/linux-header.inc"</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** format header</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="keyword">format</span> elf64 <span class="keyword">executable</span> <span class="constant">3</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** entry</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="keyword">entry</span> begin_to_interpret_threaded_code
   <span class="keyword">segment</span> <span class="keyword">readable</span> <span class="keyword">executable</span> <span class="keyword">writeable</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* macro in assembly code</span>
<span class="org-level-2">** misc</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; in fasm, "dup" is a reserved word
</span>   <span class="keyword">dup</span> <span class="preprocessor">equ</span> duplicate
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** bead_size</span>
   * 64-bits
   * note that how "xx" is used as "dq" in a 64-bits version implementation
     when one wishs to port the implementation to 32-bits machine
     just use "xx equ dd"
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   bead_size = <span class="constant">8</span> <span class="comment">;; (byte)
</span>   <span class="type">xx</span> <span class="preprocessor">equ</span> <span class="type">dq</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** argument_stack &amp; return_stack</span>
   * when doing "push"
     a stack-pointer moves to lower address
   * note that another style is that
     when doing "push"
     a stack-pointer moves to higher address
   * the stack-pointer
     always stores the address of current-free-address of the stack
   * note that another style is that
     under the stack-pointer
     there always stores the value of the-top-of-the-stack
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; if you want to extend cicada in assembly
</span>   <span class="comment">;; the following registers must NOT be used
</span>
   <span class="comment">;; =================================
</span>   <span class="preprocessor">define</span> pointer$argument_stack   <span class="variable-name">r15</span>
   <span class="preprocessor">define</span> pointer$return_stack     <span class="variable-name">r14</span>
   <span class="comment">;; =================================
</span>
   <span class="preprocessor">macro</span> <span class="function-name">push_argument_stack</span> register {
      <span class="builtin">mov</span> [pointer$argument_stack], register
      <span class="builtin">add</span> pointer$argument_stack, bead_size
      }
   <span class="preprocessor">macro</span> <span class="function-name">pop_argument_stack</span> register {
      <span class="builtin">sub</span> pointer$argument_stack, bead_size
      <span class="builtin">mov</span> register, [pointer$argument_stack]
      }

   <span class="preprocessor">macro</span> <span class="function-name">push_return_stack</span> register {
      <span class="builtin">mov</span> [pointer$return_stack], register
      <span class="builtin">add</span> pointer$return_stack, bead_size
      }
   <span class="preprocessor">macro</span> <span class="function-name">pop_return_stack</span> register {
      <span class="builtin">sub</span> pointer$return_stack, bead_size
      <span class="builtin">mov</span> register, [pointer$return_stack]
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** memory allocation in un_initialized_memory</span>
   * implemented as a memory map
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   current_free_address$un_initialized_memory = address$un_initialized_memory

   <span class="keyword">labeling</span>  <span class="preprocessor">equ</span> = current_free_address$un_initialized_memory
   <span class="type">preserve</span>  <span class="preprocessor">equ</span> current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** exit</span>
   * this makes 0 a very special jo
     one important effect is that
<span class="org-block-begin-line">     #+begin_src fasm
</span>     <span class="type">xx</span> literal, <span class="constant">0</span>
<span class="org-block-end-line">     #+end_src
</span>     is not allowed
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   exit = <span class="constant">0</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** next</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">next</span> {
      pop_return_stack <span class="variable-name">rbx</span>
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, bead_size
        <span class="builtin">mov</span> <span class="variable-name">rcx</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
        <span class="builtin">test</span> <span class="variable-name">rcx</span>, <span class="variable-name">rcx</span>
        <span class="builtin">jz</span> @f
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">@@</span>:  <span class="builtin">jmp</span> <span class="type">qword</span> [<span class="variable-name">rax</span>]
   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> play with jo &amp; jojo</span>
   1. if we have
      * the following one jojo in the return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(square)</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * and 2 in the argument-stack
        denoted by &lt;&lt; 2 &gt;&gt;
      * and as following
        the jo "square" is defined
<span class="org-block-begin-line">        #+begin_src fasm
</span>        define_function <span class="string">"square"</span>, square
           <span class="comment">;; &lt;&lt; number -- square of number &gt;&gt;
</span>           <span class="type">xx</span> <span class="keyword">dup</span>
           <span class="type">xx</span> multiple
           <span class="type">xx</span> exit
<span class="org-block-end-line">        #+end_src
</span>   2. when "next" is called
      * "next" moves the jojo on top of return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "square"
        "explain$function" is called
        to help to explain the meaning of the function-jo "square"
        the function body of the jo "square"
        is pushed to return-stack as a new jojo
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(dup)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>         <span class="return-stack-jo">(multiple)</span>
                           <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>   3. "next" is called again
      * "next" moves the jojo on top of return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>       <span class="return-stack-jo">(dup)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(multiple)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>         <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "dup"
        as a primitive-function-jo
        "dup" explains itself
        the argument-stack becomes &lt;&lt; 2, 2 &gt;&gt;
   4. "next" is called again
      * "next" moves the jojo on top of return-stack
        by the ending "exit"
        "next" recognizes that
        it is the last jo in the jojo
        so "next" pops the jojo out of return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "multiple"
        a primitive-function-jo again
        the argument-stack becomes &lt;&lt; 4 &gt;&gt;
   5. "next" is called again
      * "next" moves the jojo on top of return-stack
        by the ending "exit"
        "next" recognizes that
        it is the last jo in the jojo
        so "next" pops the jojo out of return-stack
        the return-stack is empty now
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> [  ]
<span class="org-block-end-line">        #+end_src
</span>      * "next" finds the meaning of the jo just been pulled out
        i.e. the jo "square"
        "explain$function" is called
        to help to explain the meaning of the function-jo "square"
        the function body of the jo "square"
        is pushed to return-stack as a new jojo
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(dup)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(multiple)</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>   6. "next"
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(dup)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(multiple)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * argument-stack
        &lt;&lt; 4, 4 &gt;&gt;
   7. "next"
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> [  ]
<span class="org-block-end-line">        #+end_src
</span>      * argument-stack
        &lt;&lt; 16 &gt;&gt;
   8. return-stack is empty now
      it is clear that
      if "next" is called again
      an error will occur
      actually
      in real situation
      return-stack will never be empty
      at the end of the return-stack
      there is a tail recursive function [a loop]
      which protects the return-stack from being empty
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> let us do a little review</span>
   1. at the beginning
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(square)</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * argument-stack
        &lt;&lt; 2 &gt;&gt;
   2. next
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(dup)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>         <span class="return-stack-jo">(multiple)</span>
                           <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>   3. next
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>       <span class="return-stack-jo">(dup)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(multiple)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>         <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * argument-stack
        &lt;&lt; 2, 2 &gt;&gt;
   4. next
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * argument-stack &lt;&lt; 4 &gt;&gt;
   5. next
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(dup)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(multiple)</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>   6. next
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(dup)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(multiple)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * argument-stack
        &lt;&lt; 4, 4 &gt;&gt;
   7. next
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> [  ]
<span class="org-block-end-line">        #+end_src
</span>      * argument-stack
        &lt;&lt; 16 &gt;&gt;
   8. it is really simple
      ^-^
      is it not ?
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* jo</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** link</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; initial link to point to 0 (as null)
</span>   link = <span class="constant">0</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** primitive_string_heap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   size$primitive_string_heap = <span class="constant">100</span> * <span class="constant">1024</span> <span class="comment">;; (byte)
</span>
   <span class="function-name">address$primitive_string_heap</span>:
      <span class="keyword">times</span> size$primitive_string_heap <span class="type">db</span> <span class="constant">0</span>

   current_free_address$primitive_string_heap = address$primitive_string_heap
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** make_primitive_string</span>
   * 2 bytes for length of name_string
   * note that
     the following is using local label
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">make_primitive_string</span> string {

   <span class="keyword">virtual</span> <span class="keyword">at</span> <span class="constant">0</span>
   <span class="function-name">.start$string</span>:
      <span class="type">db</span> string
   <span class="function-name">.end$string</span>:
      <span class="type">dw</span> (.end$string - .start$string)
      <span class="keyword">load</span> .length <span class="type">word</span> <span class="keyword">from</span> (.end$string)
   <span class="keyword">end</span> <span class="keyword">virtual</span>
   <span class="keyword">store</span> <span class="type">word</span> .length <span class="keyword">at</span> (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + <span class="constant">2</span>

   <span class="keyword">repeat</span> .length
      <span class="keyword">virtual</span> <span class="keyword">at</span> <span class="constant">0</span>
         <span class="type">db</span> string
         <span class="keyword">load</span> .char <span class="type">byte</span> <span class="keyword">from</span> (% - <span class="constant">1</span>)
      <span class="keyword">end</span> <span class="keyword">virtual</span>
      <span class="keyword">store</span> <span class="type">byte</span> .char <span class="keyword">at</span> (current_free_address$primitive_string_heap)
      current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + <span class="constant">1</span>
   <span class="keyword">end</span> <span class="keyword">repeat</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * note that
     after a "next" "jmp" to a explainer
     the "rax" stores the value of the jo to be explained
     so
     "rax" is used as an inexplicit argument
     of the following functions
   * explain$function is used as jojo-head
     and explains the meaning of the jojo as function
   * a jojo-head identifies one type of jo
<span class="org-level-2">** define_function</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_function</span> string, <span class="builtin">jo</span> {

   define_function__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$function

      <span class="comment">;; here follows a jojo as function-body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** explain$function</span>
   * find a jojo from a function-jo
     and push the jojo to return-stack
   * a jojo can not be of size 0 or 1
   * use rax as an argument
     which stores a jo
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$function</span>:
      <span class="builtin">add</span> <span class="variable-name">rax</span>, bead_size
      push_return_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * the same as function
     we need to redefine it
     for the value of explainer
     is used to decide the type of the jo
<span class="org-level-2">** define_macro</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_macro</span> string, <span class="builtin">jo</span> {

   define_macro__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$macro

      <span class="comment">;; here follows a jojo as function-body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** explain$macro</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$macro</span>:
      <span class="builtin">add</span> <span class="variable-name">rax</span>, bead_size
      push_return_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * primitive functions are special
     they explain themself
     and their type is not identified by jojo-head
<span class="org-level-2">** define_primitive_function</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_primitive_function</span> string, <span class="builtin">jo</span> {

   define_primitive_function__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> assembly_code__#<span class="builtin">jo</span>

   assembly_code__#<span class="builtin">jo</span>:

      <span class="comment">;; here follows assembly code
</span>      <span class="comment">;; as primitive function body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
<span class="org-level-2">** define_variable</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_variable</span> string, <span class="builtin">jo</span> {

   define_variable__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$variable

      <span class="comment">;; here follows a value of bead_size
</span>      <span class="comment">;; only one value is allowed
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** explain$variable</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$variable</span>:
      <span class="builtin">add</span> <span class="variable-name">rax</span>, bead_size
      <span class="builtin">mov</span> <span class="variable-name">rbx</span>, [<span class="variable-name">rax</span>]
      push_argument_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * explain$exception will
     1. search the return-stack for that exception
     2. special side-effect on return-stack
        to do exception handling
<span class="org-level-2">** define_exception</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_exception</span> string, <span class="builtin">jo</span> {

   define_exception__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$exception

      <span class="comment">;; here follows a jojo as function-body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> return-stack in action</span>
   1. when "explain$exception" is called
      jojo by jojo
      it searchs the jo stored in "rax" in the return-stack
      of course
      only jojo with "exception_head" as head needs to be searched
   2. for example
      we have
<span class="org-block-begin-line">      #+begin_src fasm
</span>      define_exception <span class="string">"!exception-1"</span>, !exception_1
         <span class="type">xx</span> fun1
         <span class="type">xx</span> fun2
         <span class="type">xx</span> exit
<span class="org-block-end-line">      #+end_src
</span>   3. return-stack
<span class="org-block-begin-line">      #+begin_src return-stack
</span>                                               <span class="return-stack-jo">(prepare_for)</span>
                                                 <span class="return-stack-jo">(exception_head)</span>
                                                 <span class="return-stack-jo">(!exception_1)</span>
                                                 <span class="return-stack-jo">(!exception_2)</span>
                                                 <span class="return-stack-exit">(exit)</span>
                      <span class="return-stack-jo">(prepare_for)</span>            <span class="return-stack-jo">(function_1)</span>
      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">pointer</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(exception_head)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(function_2)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(!exception_1)</span> <span class="return-stack-bar-ket">]</span>
                        <span class="return-stack-jo">(!exception_1)</span>         <span class="return-stack-exit">(exit)</span>             <span class="return-stack-exit">(exit)</span>
                        <span class="return-stack-jo">(!exception_2)</span>
                        <span class="return-stack-exit">(exit)</span>
                      <span class="return-stack-jo">(function_1)</span>
                      <span class="return-stack-jo">(function_2)</span>
                      <span class="return-stack-exit">(exit)</span>

      the pointer above is into argument-stack
<span class="org-block-end-line">      #+end_src
</span>   4. next
      * pointer$argument_stack
        should be set to the pointer above
      * and
        to call "next" again
        the return-stack should be change to
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(fun1)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(fun2)</span>
            <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> the plan</span>
   * so
     we need a two-level loop
   * note that
     although
     we have to use assembly code
     to write primitive functions
     but
     we still can use argument-stack
     to pass arguments
<span class="org-level-2">** explain$exception</span>
   * no error handling for now
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$exception</span>:
      <span class="builtin">mov</span> <span class="variable-name">rsi</span>, <span class="variable-name">rax</span>

   <span class="function-name">.next_jojo</span>:
      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">cmp</span> <span class="variable-name">rax</span>, exception_head
      <span class="builtin">je</span> .next_jo
      <span class="builtin">cmp</span> pointer$return_stack, address$return_stack
      <span class="builtin">je</span> .not_found
      <span class="builtin">jmp</span> .next_jojo


   <span class="function-name">.next_jo</span>:
      <span class="comment">;; expecting
</span>      <span class="comment">;;   rbx jojo
</span>      <span class="comment">;;   rsi jo (to cmp)
</span>      <span class="builtin">add</span> <span class="variable-name">rbx</span>, bead_size
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">cmp</span> <span class="variable-name">rax</span>, <span class="variable-name">rsi</span>
      <span class="builtin">je</span> .found
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jz</span> .next_jojo
      <span class="builtin">jmp</span> .next_jo


   <span class="function-name">.found</span>:
      <span class="comment">;; expecting
</span>      <span class="comment">;;   pointer$return_stack
</span>      <span class="comment">;;   rsi jo
</span>      pop_return_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span> pointer$argument_stack, <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="variable-name">rsi</span>, bead_size
      push_return_stack <span class="variable-name">rsi</span>
      next

   <span class="function-name">.not_found</span>:
      <span class="builtin">mov</span> sys_1_rdi, <span class="constant">15</span>
      <span class="builtin">mov</span> sys_n_rax, syscall_exit
      <span class="builtin">syscall</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** execute-jo</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"execute-jo"</span>, execute_jo
      <span class="comment">;; &lt;&lt; jo -- unknown &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">jmp</span> <span class="type">qword</span> [<span class="variable-name">rax</span>]
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** jo-&gt;name</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;name"</span>, jo_to_name
      <span class="comment">;; &lt;&lt; jo -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> literal, bead_size, subtraction
      <span class="type">xx</span> literal, bead_size, subtraction
      <span class="type">xx</span> fetch
      <span class="type">xx</span> <span class="keyword">dup</span>
      <span class="type">xx</span>   literal, <span class="constant">2</span>, addition, swap
      <span class="type">xx</span> fetch_two_bytes
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo-&gt;link</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;link"</span>, jo_to_link
      <span class="comment">;; &lt;&lt; jo -- link &gt;&gt;
</span>      <span class="type">xx</span> literal, bead_size, subtraction
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** null-jo?</span>
   * first jo in assembly code
     is the null of the linked list of jo
     so I call it null jo
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"null-jo?"</span>, null_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span> fetch
      <span class="type">xx</span> zero?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo-&gt;pre-jo</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;pre-jo"</span>, jo_to_pre_jo
      <span class="comment">;; &lt;&lt; jo -- pre-jo &gt;&gt;
</span>      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span> fetch
      <span class="type">xx</span> literal, bead_size, addition
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo-&gt;type</span>
   * the type of primitive function jo
     is encoded by 0
   * other types of jo
     are encoded by their explainers
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;type"</span>, jo_to_type
      <span class="comment">;; &lt;&lt; jo -- type &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>

      <span class="type">xx</span> <span class="keyword">dup</span>, fetch
      <span class="type">xx</span> swap, subtraction, literal, <span class="constant">8</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, zero
      <span class="type">xx</span>   exit

      <span class="type">xx</span> fetch
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** primitive-function-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"primitive-function-jo?"</span>, primitive_function_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> zero?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** function-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"function-jo?"</span>, function_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> literal, explain$function
      <span class="type">xx</span> equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** macro-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"macro-jo?"</span>, macro_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> literal, explain$macro
      <span class="type">xx</span> equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** variable-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"variable-jo?"</span>, variable_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> literal, explain$variable
      <span class="type">xx</span> equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* the story begin</span>
<span class="org-level-2">** begin_to_interpret_threaded_code</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">begin_to_interpret_threaded_code</span>:

      <span class="builtin">cld</span> <span class="comment">;; set DF = 0, then rsi and rdi are incremented
</span>
      <span class="builtin">mov</span> pointer$argument_stack,  address$argument_stack
      <span class="builtin">mov</span> pointer$return_stack,    address$return_stack

      <span class="builtin">mov</span> <span class="variable-name">rax</span>, first_jojo
      push_return_stack <span class="variable-name">rax</span>
      next


   <span class="function-name">first_jojo</span>:
      <span class="type">xx</span> basic_REPL

      <span class="comment">;; xx little_test
</span><span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** exit_with_TOS a.k.a. bye</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"bye"</span>, exit_with_TOS
      pop_argument_stack sys_1_rdi
      <span class="builtin">mov</span> sys_n_rax, syscall_exit
      <span class="builtin">syscall</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** little_test</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">""</span>, V__little_test_number
      <span class="type">xx</span> <span class="constant">3</span>


   define_function <span class="string">"little_test"</span>, little_test

      <span class="comment">;;;; variable
</span>      <span class="comment">;; xx V__little_test_number
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; 3
</span>
      <span class="comment">;;;; literal
</span>      <span class="comment">;; xx literal, 4
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; 4
</span>
      <span class="comment">;;;; address
</span>      <span class="comment">;; xx address, V__little_test_number, fetch, add2
</span>      <span class="comment">;; xx address, V__little_test_number, save
</span>      <span class="comment">;; xx V__little_test_number
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; 5
</span>
      <span class="comment">;;;; write_byte
</span>      <span class="comment">;; xx literal, 64, write_byte
</span>      <span class="comment">;; xx literal, 10, write_byte
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; @
</span>
      <span class="comment">;;;; read_byte
</span>      <span class="comment">;; xx read_byte, write_byte
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;;
</span>
      <span class="comment">;;;; branch
</span>      <span class="comment">;; xx read_byte, write_byte
</span>      <span class="comment">;; xx branch, -3
</span>      <span class="comment">;;;; read a string that ended by &lt;return&gt;
</span>      <span class="comment">;;;; write the readed string
</span>      <span class="comment">;;;; or we can say
</span>      <span class="comment">;;;; read line and write line
</span>      <span class="comment">;;;; or we can say
</span>      <span class="comment">;;;; echo line
</span>
      <span class="comment">;;;; false?branch
</span>      <span class="comment">;; xx V__false, false?branch, 9
</span>      <span class="comment">;; xx   literal, 64, write_byte
</span>      <span class="comment">;; xx   literal, 10, write_byte
</span>      <span class="comment">;; xx   zero
</span>      <span class="comment">;; xx   exit_with_TOS
</span>      <span class="comment">;; xx V__true, false?branch, 9
</span>      <span class="comment">;; xx   literal, 65, write_byte
</span>      <span class="comment">;; xx   literal, 10, write_byte
</span>      <span class="comment">;; xx   zero
</span>      <span class="comment">;; xx   exit_with_TOS
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; A
</span>
      <span class="comment">;;;; read_word &amp; write_string
</span>      <span class="comment">;; xx read_word, write_string
</span>      <span class="comment">;; xx literal, 10, write_byte
</span>      <span class="comment">;; xx read_word_for_REPL, write_string
</span>      <span class="comment">;; xx literal, 10, write_byte
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; read line
</span>      <span class="comment">;;;; write first two words of the line
</span>
      <span class="comment">;;;; string-&gt;integer
</span>      <span class="comment">;; xx read_word, string_to_integer
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;;
</span>
      <span class="comment">;;;; use jo_to_name to test the macro make_primitive_string
</span>      <span class="comment">;; xx literal, jo_to_name, jo_to_name, write_string
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;;
</span>
      <span class="comment">;;;; basic-REPL (without the ability to define function)
</span>      <span class="comment">;;;; after this test
</span>      <span class="comment">;;;; we will use basic-REPL to do further tests
</span>      <span class="type">xx</span> basic_REPL
      <span class="comment">;;;; 1 2 add .
</span><span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* argument_stack</span>
<span class="org-level-2">** memory allocation</span>
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>      <span class="type">preserve</span> <span class="constant">64</span> * bead_size
   address$argument_stack <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span> * <span class="constant">1024</span> * bead_size
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** drop</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"drop"</span>, drop
      <span class="comment">;; &lt;&lt; a -- &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"drop2"</span>, drop2
      <span class="comment">;; &lt;&lt; a b -- &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      pop_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** dup</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"dup"</span>, <span class="keyword">dup</span>
      <span class="comment">;; &lt;&lt; a -- a a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">1</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"dup2"</span>, dup2
      <span class="comment">;; &lt;&lt; a b -- a b a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rbx</span>, [pointer$argument_stack - (<span class="constant">1</span> * bead_size)]
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">2</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** over</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"over"</span>, over
      <span class="comment">;; &lt;&lt; a b -- a b | a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">2</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"x|over|xx"</span>, xoverxx
      <span class="comment">;; &lt;&lt; a | b c -- a | b c | a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">3</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|over|x"</span>, xxoverx
      <span class="comment">;; &lt;&lt; a b | c -- a b | c | a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">3</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">3</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|over|xx"</span>, xxoverxx
      <span class="comment">;; &lt;&lt; a b | c d -- a b | c d | a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">4</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">4</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"x|over|xxx"</span>, xoverxxx
      <span class="comment">;; &lt;&lt; a | b c d -- a | b c d | a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">4</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|over|xxxx"</span>, xxoverxxxx
      <span class="comment">;; &lt;&lt; a b | c d e f -- a b | c d e f | a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">6</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">6</span> * bead_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** tuck</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"tuck"</span>, tuck
      <span class="comment">;; &lt;&lt; a b -- b | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"x|tuck|xx"</span>, xtuckxx
      <span class="comment">;; &lt;&lt; a | b c -- b c | a | b c &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      next

   define_primitive_function <span class="string">"xx|tuck|x"</span>, xxtuckx
      <span class="comment">;; &lt;&lt; a b | c -- c | a b | c &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      next

   define_primitive_function <span class="string">"xx|tuck|xx"</span>, xxtuckxx
      <span class="comment">;; &lt;&lt; a b | c d -- c d | a b | c d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next

   define_primitive_function <span class="string">"xxx|tuck|x"</span>, xxxtuckx
      <span class="comment">;; &lt;&lt; a b c | d -- d | a b c | d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** swap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"swap"</span>, swap
      <span class="comment">;; &lt;&lt; a b -- b a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"x|swap|xx"</span>, xswapxx
      <span class="comment">;; &lt;&lt; a | b c -- b c | a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|swap|x"</span>, xxswapx
      <span class="comment">;; &lt;&lt; a b | c -- c | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"x|swap|xxx"</span>, xswapxxx
      <span class="comment">;; &lt;&lt; a | b c d -- b c d | a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xxx|swap|x"</span>, xxxswapx
      <span class="comment">;; &lt;&lt; a b c | d -- d | a b c &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      next

   define_primitive_function <span class="string">"xx|swap|xx"</span>, xxswapxx
      <span class="comment">;; &lt;&lt; a b | c d -- c d | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next


   define_primitive_function <span class="string">"x|swap|xxxx"</span>, xswapxxxx
      <span class="comment">;; &lt;&lt; a | b c d e -- b c d e | a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xxxx|swap|x"</span>, xxxxswapx
      <span class="comment">;; &lt;&lt; a b c d | e --  e | a b c d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next


   define_primitive_function <span class="string">"xx|swap|xxxx"</span>, xxswapxxxx
      <span class="comment">;; &lt;&lt; a b | c d e f -- c d e f | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"xxxx|swap|xx"</span>, xxxxswapxx
      <span class="comment">;; &lt;&lt; a b c d | e f --  e f | a b c d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* return_stack</span>
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>      <span class="type">preserve</span> <span class="constant">64</span> * bead_size
   address$return_stack <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span> * <span class="constant">1024</span> * bead_size
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* special</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> side-effect</span>
   * a special primitive function
     does special side-effect on return-stack
   * note that
     side-effect on return-stack
     should all be done in primitive functions
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> naming</span>
   * the naming convention in assembly code
     of special primitive function
     is the same as it of jo
   * the name of a special primitive function
     is not exported to cicada-language as a function
     but as a variable
   * the name of a special primitive function in assembly code
     maybe reused as a macro word in cicada-language
     but the name of the macro in assembly code
     is prefixed by "M__"
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> about exit</span>
   * note that
     the jo 0 is used as exit
     so
<span class="org-block-begin-line">     #+begin_src fasm
</span>     <span class="type">xx</span> literal, <span class="constant">0</span>
<span class="org-block-end-line">     #+end_src
</span>     [and so on]
     are not allowed
<span class="org-level-2">** literal</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*literal*"</span>, V__literal
      <span class="type">xx</span> literal

   define_primitive_function <span class="string">""</span>, literal
      <span class="comment">;; &lt;&lt; -- fixnum &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rbx</span>
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
        push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, bead_size
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
        <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
        <span class="builtin">jz</span> .meet_end
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">.meet_end</span>:
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** address</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*address*"</span>, V__address
      <span class="type">xx</span> address

   define_primitive_function <span class="string">""</span>, address
      <span class="comment">;; &lt;&lt; -- address &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rbx</span>
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
        <span class="builtin">add</span> <span class="variable-name">rax</span>, bead_size
        push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, bead_size
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
        <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
        <span class="builtin">jz</span> .meet_end
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">.meet_end</span>:
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** branch</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">""</span>, branch
      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
      <span class="builtin">imul</span> <span class="variable-name">rax</span>, bead_size
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      <span class="comment">;; the following handles branching to "exit"
</span>      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jz</span> .meet_end
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">.meet_end</span>:
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** false?branch</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">""</span>, false?branch
      <span class="comment">;; &lt;&lt; true of false -- &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jnz</span> help__false?branch__not_to_branch

      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
      <span class="builtin">imul</span> <span class="variable-name">rax</span>, bead_size
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      <span class="comment">;; the following handles branching to "exit"
</span>      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jz</span> .meet_end
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">.meet_end</span>:
      next

   <span class="function-name">help__false?branch__not_to_branch</span>:
      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, bead_size
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jz</span> .meet_end
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">.meet_end</span>:
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> return-stack in action</span>
   1. when executing the following code block
<span class="org-block-begin-line">      #+begin_src fasm
</span>      <span class="type">xx</span> prepare_for
      <span class="type">xx</span> exception_head
      <span class="type">xx</span>   !exception_1
      <span class="type">xx</span>   !exception_2
      <span class="type">xx</span>   exit
      <span class="type">xx</span> function_1
      <span class="type">xx</span> function_2
      <span class="type">xx</span> exit
<span class="org-block-end-line">      #+end_src
</span>   2. return-stack
<span class="org-block-begin-line">      #+begin_src return-stack
</span>      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(prepare_for)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(exception_head)</span>
            <span class="return-stack-jo">(!exception_1)</span>
            <span class="return-stack-jo">(!exception_2)</span>
            <span class="return-stack-exit">(exit)</span>
          <span class="return-stack-jo">(function_1)</span>
          <span class="return-stack-jo">(function_2)</span>
          <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">      #+end_src
</span>   3. next
      * this is how the return-stack looks
        right before exception_head is executed
<span class="org-block-begin-line">        #+begin_src return-stack
</span>          <span class="return-stack-jo">(prepare_for)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(exception_head)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(!exception_1)</span>
            <span class="return-stack-jo">(!exception_2)</span>
            <span class="return-stack-exit">(exit)</span>
          <span class="return-stack-jo">(function_1)</span>
          <span class="return-stack-jo">(function_2)</span>
          <span class="return-stack-exit">(exit)</span>
<span class="org-block-end-line">        #+end_src
</span>      * after exception_head is executed
<span class="org-block-begin-line">        #+begin_src return-stack
</span>                                                 <span class="return-stack-jo">(prepare_for)</span>
                                                   <span class="return-stack-jo">(exception_head)</span>
                                                   <span class="return-stack-jo">(!exception_1)</span>
                                                   <span class="return-stack-jo">(!exception_2)</span>
                        <span class="return-stack-jo">(prepare_for)</span>              <span class="return-stack-exit">(exit)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">pointer</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(exception_head)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(function_1)</span> <span class="return-stack-bar-ket">]</span>
                          <span class="return-stack-jo">(!exception_1)</span>         <span class="return-stack-jo">(function_2)</span>
                          <span class="return-stack-jo">(!exception_2)</span>         <span class="return-stack-exit">(exit)</span>
                          <span class="return-stack-exit">(exit)</span>
                        <span class="return-stack-jo">(function_1)</span>
                        <span class="return-stack-jo">(function_2)</span>
                        <span class="return-stack-exit">(exit)</span>

        the pointer above is into argument-stack
<span class="org-block-end-line">        #+end_src
</span><span class="org-level-2">** prepare_for</span>
   * prepare for a list of exceptions
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">""</span>, prepare_for
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rbx</span>
      push_return_stack pointer$argument_stack
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">.next</span>:
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, bead_size
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jz</span> .then
      <span class="builtin">jmp</span> .next
   <span class="function-name">.then</span>:
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, bead_size
      push_return_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** exception_head</span>
   * this jo is served as a label in return-stack
     when explained
     it pops the jojo itself in
     and
     it pops the argument-stack pointer after it
   * and "explain$exception" will search for them
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">""</span>, exception_head
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rax</span>
      pop_return_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* bool</span>
<span class="org-level-2">** false &amp; true</span>
   * they are defined as function
     and viewed as constant
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"false"</span>, false
      <span class="comment">;; &lt;&lt; -- false &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"true"</span>, true
      <span class="comment">;; &lt;&lt; -- true &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">inc</span> <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** false? &amp; true?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"false?"</span>, false?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> false, equal?
      <span class="type">xx</span> exit

   define_function <span class="string">"true?"</span>, true?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> true, equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** bitwise operations</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"bitwise-and"</span>, bitwise_and
      <span class="comment">;; &lt;&lt; a, b -- a and b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      <span class="builtin">and</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"bitwise-or"</span>, bitwise_or
      <span class="comment">;; &lt;&lt; a, b -- a or b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      <span class="builtin">or</span>  [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"bitwise-xor"</span>, bitwise_xor
      <span class="comment">;; &lt;&lt; a, b -- a xor b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      <span class="builtin">xor</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"bitwise-invert"</span>, bitwise_invert
      <span class="comment">;; &lt;&lt; a -- invert a &gt;&gt;
</span>      <span class="builtin">not</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)]
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* fixnum</span>
<span class="org-level-2">** zero &amp; one</span>
   * they are defined as function
     and viewed as constant
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"zero"</span>, zero
      <span class="comment">;; &lt;&lt; -- 0 &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"one"</span>, one
      <span class="comment">;; &lt;&lt; -- 1 &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">inc</span> <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** zero? &amp; one?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"zero?"</span>, zero?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> zero, equal?
      <span class="type">xx</span> exit

   define_function <span class="string">"one?"</span>, one?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> one, equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** add &amp; sub &amp; mul &amp; div &amp; mod &amp; negate &amp; power</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"add1"</span>, add1
      <span class="comment">;; &lt;&lt; n -- n+1 &gt;&gt;
</span>      <span class="builtin">inc</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)]
      next

   define_primitive_function <span class="string">"add2"</span>, add2
      <span class="comment">;; &lt;&lt; n -- n+2 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">2</span>
      next

   define_primitive_function <span class="string">"add3"</span>, add3
      <span class="comment">;; &lt;&lt; n -- n+3 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">3</span>
      next

   define_primitive_function <span class="string">"add4"</span>, add4
      <span class="comment">;; &lt;&lt; n -- n+4 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">4</span>
      next

   define_primitive_function <span class="string">"add8"</span>, add8
      <span class="comment">;; &lt;&lt; n -- n+8 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">8</span>
      next


   define_primitive_function <span class="string">"sub1"</span>, sub1
      <span class="comment">;; &lt;&lt; n -- n-1 &gt;&gt;
</span>      <span class="builtin">dec</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)]
      next

   define_primitive_function <span class="string">"sub2"</span>, sub2
      <span class="comment">;; &lt;&lt; n -- n-2 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">2</span>
      next

   define_primitive_function <span class="string">"sub3"</span>, sub3
      <span class="comment">;; &lt;&lt; n -- n-3 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">3</span>
      next

   define_primitive_function <span class="string">"sub4"</span>, sub4
      <span class="comment">;; &lt;&lt; n -- n-4 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">4</span>
      next

   define_primitive_function <span class="string">"sub8"</span>, sub8
      <span class="comment">;; &lt;&lt; n -- n-8 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="constant">8</span>
      next


   define_primitive_function <span class="string">"add"</span>, addition
      <span class="comment">;; &lt;&lt; a b -- a+b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"sub"</span>, subtraction
      <span class="comment">;; &lt;&lt; a b -- a-b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * bead_size)], <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"mul"</span>, multiple
      <span class="comment">;; &lt;&lt; a b -- a*b &gt;&gt;
</span>      pop_argument_stack  <span class="variable-name">rbx</span> <span class="comment">;; 2ed arg
</span>      pop_argument_stack  <span class="variable-name">rax</span> <span class="comment">;; 1st arg
</span>      <span class="builtin">imul</span> <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      <span class="comment">;; imul will ignore overflow
</span>      <span class="comment">;; when there are two registers as arg
</span>      <span class="comment">;; imul will save the result into the first register
</span>      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"moddiv"</span>, moddiv
      <span class="comment">;; &lt;&lt; a, b -- a mod b, quotient &gt;&gt;
</span>      <span class="comment">;; &lt;&lt; dividend, divisor -- remainder, quotient &gt;&gt;
</span>      <span class="comment">;; the arg of idiv is divisor
</span>      <span class="comment">;; the lower half of dividend is taken from rax
</span>      <span class="comment">;; the upper half of dividend is taken from rdx
</span>      <span class="builtin">xor</span>  <span class="variable-name">rdx</span>, <span class="variable-name">rdx</span>   <span class="comment">;; high-part of dividend is not used
</span>      pop_argument_stack  <span class="variable-name">rbx</span> <span class="comment">;; 2ed arg
</span>      pop_argument_stack  <span class="variable-name">rax</span> <span class="comment">;; 1st arg
</span>      <span class="builtin">idiv</span> <span class="variable-name">rbx</span>
      <span class="comment">;; the remainder is stored in rdx
</span>      <span class="comment">;; the quotient  is stored in rax
</span>      push_argument_stack <span class="variable-name">rdx</span> <span class="comment">;; remainder
</span>      push_argument_stack <span class="variable-name">rax</span> <span class="comment">;; quotient
</span>      next


   define_function <span class="string">"divmod"</span>, divmod
      <span class="comment">;; &lt;&lt; a, b -- quotient, a mod b &gt;&gt;
</span>      <span class="type">xx</span> moddiv, swap
      <span class="type">xx</span> exit

   define_function <span class="string">"div"</span>, division
      <span class="comment">;; &lt;&lt; a, b -- quotient &gt;&gt;
</span>      <span class="type">xx</span> divmod, drop
      <span class="type">xx</span> exit

   define_function <span class="string">"mod"</span>, modulo
      <span class="comment">;; &lt;&lt; a, b -- a mod b &gt;&gt;
</span>      <span class="type">xx</span> moddiv, drop
      <span class="type">xx</span> exit

   define_function <span class="string">"negate"</span>, negate
      <span class="comment">;; &lt;&lt; n --  -n &gt;&gt;
</span>      <span class="type">xx</span> zero
      <span class="type">xx</span> swap, subtraction
      <span class="type">xx</span> exit


   define_function <span class="string">"power"</span>, power
      <span class="comment">;; n must be nature number for now
</span>      <span class="comment">;; &lt;&lt; a, n -- a^n &gt;&gt;
</span>      <span class="type">xx</span> literal, <span class="constant">1</span>, swap <span class="comment">;; leave product
</span>      <span class="type">xx</span> help__power
      <span class="type">xx</span> exit

   define_function <span class="string">"help,power"</span>, help__power
      <span class="comment">;; &lt;&lt; a, product, n -- a^n &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">5</span>
      <span class="type">xx</span>   drop, swap, drop
      <span class="type">xx</span>   exit
      <span class="type">xx</span> sub1
      <span class="type">xx</span> swap
      <span class="type">xx</span>   xoverxx, multiple
      <span class="type">xx</span> swap
      <span class="type">xx</span> help__power
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** equal &amp; greater-than &amp; less-than</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"equal?"</span>, equal?
      <span class="comment">;; &lt;&lt; a, b -- a, b, true of false &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      <span class="builtin">sete</span>  <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"less-than?"</span>, less_than?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setl</span>  <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"greater-than?"</span>, greater_than?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setg</span>  <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack  <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"less-or-equal?"</span>, less_or_equal?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setle</span> <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"greater-or-equal?"</span>, greater_or_equal?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setge</span> <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** negative? &amp; positive?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"negative?"</span>, negative?
      <span class="comment">;; &lt;&lt; integer -- bool &gt;&gt;
</span>      <span class="type">xx</span> zero, less_than?
      <span class="type">xx</span> exit

   define_function <span class="string">"positive?"</span>, positive?
      <span class="comment">;; &lt;&lt; integer -- bool &gt;&gt;
</span>      <span class="type">xx</span> negative?, false?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* memory</span>
  * although the following functions are all side-effect
    but I use "save" instead of "save!"
<span class="org-block-begin-line">  #+begin_src fasm :tangle cicada-nymph.fasm
</span>  <span class="comment">;; "save" and "fetch" default to a bead_size
</span>  <span class="comment">;; the rule of "fetch2" and so on are:
</span>  <span class="comment">;;   in memory:
</span>  <span class="comment">;;     ||  1 : value-1  ||
</span>  <span class="comment">;;     ||  1 : value-2  ||
</span>  <span class="comment">;;     ||  1 : value-3  ||
</span>  <span class="comment">;;     ...
</span>  <span class="comment">;;   on stack:
</span>  <span class="comment">;;     &lt;&lt; value-1, value-2, value-3, ... &gt;&gt;
</span>  <span class="comment">;; of course we have:
</span>  <span class="comment">;;   fetch2 : memory=copy=&gt;stack
</span>  <span class="comment">;;   save2  : stack-&gt;memory
</span>
  define_primitive_function <span class="string">"save"</span>, save
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">qword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"save-byte"</span>, save_byte
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">byte</span>[<span class="variable-name">rbx</span>], <span class="variable-name">al</span>
     next

  define_primitive_function <span class="string">"save-two-bytes"</span>, save_two_bytes
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">word</span> [<span class="variable-name">rbx</span>], <span class="variable-name">ax</span>
     next

  define_primitive_function <span class="string">"save-four-bytes"</span>, save_four_bytes
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">dword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">eax</span>
     next

  define_primitive_function <span class="string">"n-save"</span>, n_save
     <span class="comment">;; &lt;&lt; value-n, ..., value-1, address, n -- &gt;&gt;
</span>     pop_argument_stack <span class="variable-name">rcx</span>
     pop_argument_stack <span class="variable-name">rdx</span>
     <span class="builtin">mov</span> <span class="variable-name">rax</span>, bead_size
     <span class="builtin">imul</span> <span class="variable-name">rax</span>, <span class="variable-name">rcx</span>
     <span class="builtin">add</span> <span class="variable-name">rdx</span>, <span class="variable-name">rax</span>
     <span class="comment">;; for address is based on 0
</span>     <span class="comment">;; but n is based on 1
</span>     <span class="builtin">sub</span> <span class="variable-name">rdx</span>, bead_size
  <span class="function-name">.loop</span>:
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">qword</span> [<span class="variable-name">rdx</span>], <span class="variable-name">rax</span>
     <span class="builtin">sub</span> <span class="variable-name">rdx</span>, bead_size
     <span class="builtin">loop</span> .loop
     next

  define_function <span class="string">"save2"</span>, save2
     <span class="comment">;; &lt;&lt; value-2, value-1, address -- &gt;&gt;
</span>     <span class="type">xx</span> literal, <span class="constant">2</span>
     <span class="type">xx</span> n_save
     <span class="type">xx</span> exit

  define_primitive_function <span class="string">"n-save-byte"</span>, n_save_byte
     <span class="comment">;; &lt;&lt; value-n, ..., value-1, address, n -- &gt;&gt;
</span>     pop_argument_stack <span class="variable-name">rcx</span>
     pop_argument_stack <span class="variable-name">rdx</span>
     <span class="builtin">add</span> <span class="variable-name">rdx</span>, <span class="variable-name">rcx</span>
     <span class="builtin">dec</span> <span class="variable-name">rdx</span>
  <span class="function-name">.loop</span>:
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">byte</span> [<span class="variable-name">rdx</span>], <span class="variable-name">al</span>
     <span class="builtin">dec</span> <span class="variable-name">rdx</span>
     <span class="builtin">loop</span> .loop
     next

  define_primitive_function <span class="string">"fetch"</span>, fetch
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack  <span class="variable-name">rbx</span>
     <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"fetch-byte"</span>, fetch_byte
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="variable-name">al</span>, <span class="type">byte</span>[<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next
  define_primitive_function <span class="string">"fetch-two-bytes"</span>, fetch_two_bytes
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="variable-name">ax</span>, <span class="type">word</span> [<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"fetch-four-bytes"</span>, fetch_four_bytes
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="variable-name">eax</span>, <span class="type">dword</span> [<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next

  <span class="comment">;;   in memory:
</span>  <span class="comment">;;     ||  1 : value-1  ||
</span>  <span class="comment">;;     ...
</span>  <span class="comment">;;     ||  1 : value-n  ||
</span>  define_primitive_function <span class="string">"n-fetch"</span>, n_fetch
     <span class="comment">;; &lt;&lt; address, n -- value-1, ..., value-n &gt;&gt;
</span>     pop_argument_stack  <span class="variable-name">rcx</span>
     pop_argument_stack  <span class="variable-name">rdx</span>
  <span class="function-name">.loop</span>:
     <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rdx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">add</span> <span class="variable-name">rdx</span>, bead_size
     <span class="builtin">loop</span> .loop
     next

  define_primitive_function <span class="string">"n-fetch-byte"</span>, n_fetch_byte
     <span class="comment">;; &lt;&lt; address, n -- byte-1, ..., byte-n &gt;&gt;
</span>     pop_argument_stack  <span class="variable-name">rcx</span>
     pop_argument_stack  <span class="variable-name">rdx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
  <span class="function-name">.loop</span>:
     <span class="builtin">mov</span> <span class="variable-name">al</span>, <span class="type">byte</span> [<span class="variable-name">rdx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">inc</span> <span class="variable-name">rdx</span>
     <span class="builtin">loop</span> .loop
     next

  define_function <span class="string">"fetch2"</span>, fetch2
     <span class="comment">;; &lt;&lt; address -- value-1, value-2 &gt;&gt;
</span>     <span class="type">xx</span> literal, <span class="constant">2</span>
     <span class="type">xx</span> n_fetch
     <span class="type">xx</span> exit

  define_primitive_function <span class="string">"add-save"</span>, add_save
     <span class="comment">;; ( number to add, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">add</span> <span class="type">qword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"sub-save"</span>, sub_save
     <span class="comment">;; ( number to add, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">sub</span> <span class="type">qword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">rax</span>
     next
<span class="org-block-end-line">  #+end_src
</span><span class="org-level-1">* io</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> byte</span>
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   max_input_length = <span class="constant">1024</span> * <span class="constant">1024</span>

   buffer$read_byte <span class="keyword">labeling</span>
      <span class="type">preserve</span> max_input_length
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** write-byte</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">buffer$write_byte</span>:
      <span class="type">db</span> <span class="constant">0</span>

   define_primitive_function <span class="string">"write-byte"</span>, write_byte
      <span class="comment">;; &lt;&lt; byte -- &gt;&gt;
</span>      <span class="comment">;; just calls the Linux write system call
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="comment">;; write can not just write the char in al to stdout
</span>      <span class="comment">;; write needs the address of the byte to write
</span>      <span class="builtin">mov</span> [buffer$write_byte], <span class="variable-name">al</span>
      <span class="builtin">mov</span> sys_3_rdx, <span class="constant">1</span>                 <span class="comment">;; max length to be write
</span>      <span class="builtin">mov</span> sys_2_rsi, buffer$write_byte <span class="comment">;; address
</span>      <span class="builtin">mov</span> sys_1_rdi, <span class="constant">1</span>                 <span class="comment">;; stdout
</span>      <span class="builtin">mov</span> sys_n_rax, syscall_write
      <span class="builtin">syscall</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-byte</span>
   * calls the Linux read system call to fill buffer$read_byte
   * if it detects that stdin has closed
     it exits the program
     which is why when you hit C-d the system exits
   * add the teature to unread one ket-char
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">flag$unreaded_ket_char</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   <span class="function-name">char$unreaded_ket_char</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   define_function <span class="string">"have-unreaded-ket-char?"</span>, have_unreaded_ket_char?
      <span class="comment">;; &lt;&lt; -- bool &gt;&gt;
</span>      <span class="type">xx</span> literal, flag$unreaded_ket_char, fetch
      <span class="type">xx</span> exit

   define_function <span class="string">"unread-ket-char"</span>, unread_ket_char
      <span class="comment">;; &lt;&lt; char -- &gt;&gt;
</span>      <span class="type">xx</span> literal, char$unreaded_ket_char, save
      <span class="type">xx</span> true, literal, flag$unreaded_ket_char, save
      <span class="type">xx</span> exit


   <span class="comment">;; help__read_byte is the old do function without unread ket-char
</span>   define_function <span class="string">"read-byte"</span>, read_byte
      <span class="comment">;; &lt;&lt; -- byte &gt;&gt;
</span>      <span class="type">xx</span> have_unreaded_ket_char?, false?branch, <span class="constant">9</span>
      <span class="type">xx</span>   literal, char$unreaded_ket_char, fetch_byte
      <span class="type">xx</span>   zero, literal, flag$unreaded_ket_char, save
      <span class="type">xx</span>   exit
      <span class="type">xx</span> help__read_byte
      <span class="type">xx</span> exit



   <span class="function-name">cursor$read_byte</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   <span class="function-name">border$read_byte</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   define_primitive_function <span class="string">"help,read-byte"</span>, help__read_byte
      <span class="comment">;; &lt;&lt; -- byte &gt;&gt;
</span>      <span class="builtin">call</span> help__help__read_byte
      push_argument_stack <span class="variable-name">rax</span>
      next


   <span class="function-name">help__help__read_byte</span>:
      <span class="builtin">mov</span> <span class="variable-name">rbx</span>, [cursor$read_byte]
      <span class="builtin">cmp</span> <span class="variable-name">rbx</span>, [border$read_byte]
      <span class="comment">;; [cursor$read_byte] &lt;  [border$read_byte]
</span>      <span class="builtin">jl</span> .we_still_have_buffered_byte
      <span class="comment">;; [cursor$read_byte] &gt;= [border$read_byte]
</span>      <span class="builtin">jmp</span> .do_a_new_buffer


   <span class="function-name">.do_a_new_buffer</span>:
      <span class="builtin">mov</span> <span class="variable-name">rbx</span>, buffer$read_byte
      <span class="builtin">mov</span> [cursor$read_byte], <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> [border$read_byte], <span class="variable-name">rbx</span>

      <span class="builtin">mov</span> sys_3_rdx, max_input_length <span class="comment">;; max length to be read
</span>      <span class="builtin">mov</span> sys_2_rsi, buffer$read_byte <span class="comment">;; buffer address
</span>      <span class="builtin">xor</span> sys_1_rdi, sys_1_rdi        <span class="comment">;; stdin
</span>      <span class="builtin">mov</span> sys_n_rax, syscall_read
      <span class="builtin">syscall</span>
      <span class="comment">;; the return value of syscall read
</span>      <span class="comment">;; is a count of the number of bytes transferred
</span>      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jz</span> .error <span class="comment">;; rax = 0
</span>      <span class="builtin">js</span> .error <span class="comment">;; rax &lt; 0
</span>
      <span class="comment">;; update [border$read_byte]
</span>      <span class="builtin">add</span> [border$read_byte], <span class="variable-name">rax</span>
      <span class="builtin">jmp</span> help__help__read_byte


   <span class="function-name">.we_still_have_buffered_byte</span>:
      <span class="comment">;; for the following will just uses the al part of rax
</span>      <span class="comment">;; it is necessary to clear rax
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">mov</span> <span class="variable-name">al</span>, <span class="type">byte</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">inc</span> <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> [cursor$read_byte], <span class="variable-name">rbx</span>
      <span class="builtin">ret</span>


   <span class="function-name">.error</span>:
      <span class="comment">;; exit with exit code = 0
</span>      <span class="builtin">xor</span> sys_1_rdi, sys_1_rdi
      <span class="builtin">mov</span> sys_n_rax, syscall_exit
      <span class="builtin">syscall</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> word</span>
   * words are separated by spaces
   * a bar-ket is a word
     even when there are no spaces around it
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   max_word_length = <span class="constant">1024</span>

   buffer$read_word <span class="keyword">labeling</span>
      <span class="type">preserve</span> max_word_length

   buffer$read_word_for_REPL <span class="keyword">labeling</span>
      <span class="type">preserve</span> max_word_length
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word-begin-char</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word-begin-char"</span>, read_word_begin_char
      <span class="comment">;; &lt;&lt; -- non-blank-char &gt;&gt;
</span>      <span class="type">xx</span> read_byte
      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="constant">32</span> <span class="comment">;; ascii.space
</span>      <span class="type">xx</span> greater_than?, false?branch, <span class="constant">2</span>
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop
      <span class="type">xx</span> read_word_begin_char
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word-&gt;buffer</span>
   1. skip any space-char (whitespace newline)
   2. call read_char to read characters into buffer
      until it hits a blank
   3. return the address of buffer and length to argument_stack
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word-&gt;buffer"</span>, read_word_to_buffer
      <span class="comment">;; &lt;&lt; buffer -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> read_word_begin_char
      <span class="comment">;; no metter what the begin char is
</span>      <span class="comment">;; save it into buffer
</span>      <span class="type">xx</span> dup2, swap, save_byte
      <span class="type">xx</span> swap, add1, swap
      <span class="type">xx</span> one, swap <span class="comment">;; leave length counter
</span>      <span class="comment">;; &lt;&lt; cursor[address in buffer], counter, begin char &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, bar_ket_char?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop
      <span class="type">xx</span>   help__read_word_to_buffer__bar_ket
      <span class="type">xx</span>   exit
      <span class="comment">;; maybe add other type of chars
</span>      <span class="type">xx</span> drop
      <span class="type">xx</span> help__read_word_to_buffer__regular
      <span class="type">xx</span> exit

   define_function <span class="string">"help,read-word-&gt;buffer,bar-ket"</span>, help__read_word_to_buffer__bar_ket
      <span class="comment">;; &lt;&lt; cursor[address in buffer], counter -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> tuck, subtraction, swap
      <span class="type">xx</span> exit

   define_function <span class="string">"help,read-word-&gt;buffer,regular"</span>, help__read_word_to_buffer__regular
      <span class="comment">;; &lt;&lt; cursor[address in buffer], counter -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> read_byte
      <span class="type">xx</span> <span class="keyword">dup</span>, bar_ket_char?, false?branch, <span class="constant">6</span>
      <span class="type">xx</span>   unread_ket_char
      <span class="type">xx</span>   tuck, subtraction, swap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, space_char?, false?branch, <span class="constant">6</span>
      <span class="type">xx</span>   drop
      <span class="type">xx</span>   tuck, subtraction, swap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> xoverxx, save_byte
      <span class="type">xx</span> add1
      <span class="type">xx</span> swap, add1, swap
      <span class="type">xx</span> help__read_word_to_buffer__regular
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word"</span>, read_word
      <span class="comment">;; &lt;&lt; -- word[address of buffer$read_word, length] &gt;&gt;
</span>      <span class="type">xx</span> literal, buffer$read_word, read_word_to_buffer
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word-for-REPL</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word-for-REPL"</span>, read_word_for_REPL
      <span class="comment">;; &lt;&lt; -- word[address of buffer$read_word_for_REPL, length] &gt;&gt;
</span>      <span class="type">xx</span> literal, buffer$read_word_for_REPL, read_word_to_buffer
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> string</span>
<span class="org-level-2">** write-string</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"write-string"</span>, write_string
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   exit
      <span class="type">xx</span> sub1, swap
      <span class="type">xx</span> <span class="keyword">dup</span>, fetch_byte, write_byte
      <span class="type">xx</span> add1, swap
      <span class="type">xx</span> write_string
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** pretty_write_string</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">".s"</span>, pretty_write_string
      <span class="comment">;; &lt;&lt; integer -- &gt;&gt;
</span>      <span class="type">xx</span> write_string
      <span class="type">xx</span> literal, <span class="constant">10</span>, write_byte
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** write-nature-number</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; 2 ^ 64 = 18446744073709551616
</span>   <span class="comment">;; which is of length 20
</span>   <span class="comment">;; so
</span>   <span class="comment">;; I use 32 to align to 16
</span>
   buffer$write_nature_number <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">32</span>

   <span class="function-name">counter$write_nature_number</span>:
      <span class="type">xx</span> <span class="constant">0</span>


   define_function <span class="string">"write-nature-number"</span>, write_nature_number
      <span class="comment">;; &lt;&lt; nature-number -- &gt;&gt;
</span>      <span class="type">xx</span> zero
      <span class="type">xx</span> literal, counter$write_nature_number, save

      <span class="type">xx</span> help__write_nature_number

      <span class="type">xx</span> literal, buffer$write_nature_number
      <span class="type">xx</span> literal, counter$write_nature_number, fetch
      <span class="type">xx</span> string_reverse!
      <span class="type">xx</span> write_string
      <span class="type">xx</span> exit


   define_function <span class="string">"help,write-nature-number"</span>, help__write_nature_number
      <span class="comment">;; &lt;&lt; rest-number -- &gt;&gt;
</span>      <span class="type">xx</span> literal, <span class="constant">10</span>, divmod

      <span class="type">xx</span> decimal_digital_to_char
      <span class="type">xx</span> literal, buffer$write_nature_number
      <span class="type">xx</span> literal, counter$write_nature_number, fetch
      <span class="type">xx</span> addition
      <span class="type">xx</span> save_byte

      <span class="type">xx</span> one
      <span class="type">xx</span> literal, counter$write_nature_number
      <span class="type">xx</span> add_save

      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   drop
      <span class="type">xx</span>   exit
      <span class="type">xx</span> help__write_nature_number
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** write-integer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"write-integer"</span>, write_integer
      <span class="comment">;; &lt;&lt; integer -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, positive?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   write_nature_number
      <span class="type">xx</span>   exit
      <span class="type">xx</span> literal, <span class="default">'-'</span>, write_byte
      <span class="type">xx</span> negate, write_nature_number
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** pretty_write_integer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"."</span>, pretty_write_integer
      <span class="comment">;; &lt;&lt; integer -- &gt;&gt;
</span>      <span class="type">xx</span> write_integer
      <span class="type">xx</span> literal, <span class="constant">32</span>, write_byte
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* char</span>
<span class="org-level-2">** space-char?</span>
   * as for space-char
     I only use two
     ASCII 10 (newline)
     ASCII 32 (whitespace)
   * note that
     I use the term "whitespace" to denotes the char
     I use the term "space" to denotes the set of chars
   * I will simply view number less-or-equal 32 as space-char
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"space-char?"</span>, space_char?
      <span class="comment">;; &lt;&lt; char -- bool &gt;&gt;
</span>      <span class="type">xx</span> literal, <span class="constant">32</span>, less_or_equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** bar-ket-char?</span>
   * () [] {}
     but not &lt;&gt;
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"bar-ket-char?"</span>, bar_ket_char?
      <span class="comment">;; &lt;&lt; char -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">'('</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">')'</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">'['</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">']'</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">'{'</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">'}'</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop, false
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** decimal-digital-char?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"digital-char?"</span>, decimal_digital_char?
      <span class="comment">;; &lt;&lt; char -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">'0'</span>, less_than?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, false
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, literal, <span class="default">'9'</span>, less_or_equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop, false
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> digital</span>
   * a decimal-digital is number from 0 to 9
   * a binary-digital is number from 0 to 1
<span class="org-level-2">** char-&gt;decimal-digital &amp; decimal-digital-&gt;char</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"char-&gt;decimal-digital"</span>, char_to_decimal_digital
      <span class="comment">;; &lt;&lt; char -- decimal-digital &gt;&gt;
</span>      <span class="type">xx</span> literal, <span class="default">'0'</span>, subtraction
      <span class="type">xx</span> exit

   define_function <span class="string">"decimal-digital-&gt;char"</span>, decimal_digital_to_char
      <span class="comment">;; &lt;&lt; decimal-digital -- char &gt;&gt;
</span>      <span class="type">xx</span> literal, <span class="default">'0'</span>, addition
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* buffer</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * a buffer is a large vector
     and some functions do not care about how large it is
<span class="org-level-2">** compare-buffer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; return false when length == 0
</span>   define_primitive_function <span class="string">"compare-buffer"</span>, compare_buffer
      <span class="comment">;; &lt;&lt; address, address, length -- bool &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rdi</span>
      pop_argument_stack <span class="variable-name">rsi</span>
      <span class="builtin">repe</span> <span class="builtin">cmpsb</span>
      <span class="builtin">sete</span> <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* string</span>
<span class="org-level-2">** string-equal?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-equal?"</span>, string_equal?
      <span class="comment">;; &lt;&lt; string[address, length], string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> xoverxx, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   swap, compare_buffer
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop, drop2
      <span class="type">xx</span> false
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-[head|tail],char</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-head,char"</span>, string_head__char
      <span class="comment">;; &lt;&lt; string[address, length] -- char &gt;&gt;
</span>      <span class="type">xx</span> drop, fetch_byte
      <span class="type">xx</span> exit

   define_function <span class="string">"string-tail,char"</span>, string_tail__char
      <span class="comment">;; &lt;&lt; string[address, length] -- [address + 1, length + 1] &gt;&gt;
</span>      <span class="type">xx</span> sub1, swap
      <span class="type">xx</span> add1, swap
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-&gt;buffer!</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"string-&gt;buffer!"</span>, string_to_buffer!
      <span class="comment">;; ( string[address, length], buffer[address] -- )
</span>      pop_argument_stack <span class="variable-name">rdi</span> <span class="comment">;; destination
</span>      pop_argument_stack <span class="variable-name">rcx</span> <span class="comment">;; counter
</span>      pop_argument_stack <span class="variable-name">rsi</span> <span class="comment">;; source
</span>      <span class="builtin">rep</span> <span class="builtin">movsb</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-reverse!</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   buffer$string_reverse! <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span>


   define_primitive_function <span class="string">"string-reverse!"</span>, string_reverse!
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="builtin">mov</span> <span class="variable-name">rdi</span>, buffer$string_reverse!
      <span class="builtin">mov</span> <span class="variable-name">rcx</span>, [pointer$argument_stack - (<span class="constant">1</span> * bead_size)]
      <span class="builtin">mov</span> <span class="variable-name">rsi</span>, [pointer$argument_stack - (<span class="constant">2</span> * bead_size)]
      <span class="builtin">rep</span> <span class="builtin">movsb</span>

      <span class="builtin">mov</span> <span class="variable-name">rcx</span>, [pointer$argument_stack - (<span class="constant">1</span> * bead_size)]
      <span class="builtin">dec</span> <span class="variable-name">rdi</span> <span class="comment">;; cursor back into string in buffer$string_reverse!
</span>      <span class="builtin">mov</span> <span class="variable-name">rsi</span>, [pointer$argument_stack - (<span class="constant">2</span> * bead_size)]
   <span class="function-name">.loop</span>:
      <span class="builtin">mov</span> <span class="variable-name">al</span>, <span class="type">byte</span> [<span class="variable-name">rdi</span>]
      <span class="builtin">mov</span> <span class="type">byte</span> [<span class="variable-name">rsi</span>], <span class="variable-name">al</span>
      <span class="builtin">dec</span> <span class="variable-name">rdi</span>
      <span class="builtin">inc</span> <span class="variable-name">rsi</span>
      <span class="builtin">loop</span> .loop

      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** digital-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"digital-string?"</span>, digital_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> over, fetch_byte, decimal_digital_char?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   string_tail__char
      <span class="type">xx</span>   digital_string?
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop2, false
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** char-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"char-string?"</span>, char_string?
      <span class="comment">;; &lt;&lt; string[address, length], char -- bool &gt;&gt;
</span>      <span class="type">xx</span> xxswapx
      <span class="type">xx</span> <span class="keyword">dup</span>, one?, false?, false?branch, <span class="constant">5</span>
      <span class="type">xx</span>   drop2, drop
      <span class="type">xx</span>   false
      <span class="type">xx</span>   exit
      <span class="type">xx</span> string_head__char, equal?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> false
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** zero-string?</span>
   * "0" or "-0"
     0 is special when compiling literal number
     for we are using 0 as "exit"
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"zero-string?"</span>, zero_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> dup2, literal, <span class="default">'0'</span>, char_string?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_head__char, literal, <span class="default">'-'</span>, equal?, false?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, false
      <span class="type">xx</span>   exit
      <span class="type">xx</span> string_tail__char, literal, <span class="default">'0'</span>, char_string?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** integer-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"integer-string?"</span>, integer_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, false
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, literal, <span class="default">'-'</span>, char_string?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, false
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, string_head__char, literal, <span class="default">'-'</span>, equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   string_tail__char, digital_string?
      <span class="type">xx</span>   exit
      <span class="type">xx</span> digital_string?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-&gt;integer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-&gt;integer"</span>, string_to_integer
      <span class="comment">;; &lt;&lt; string[address, length] -- integer &gt;&gt;
</span>      <span class="type">xx</span> dup2, string_head__char, literal, <span class="default">'-'</span>, equal?, false?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   digital_string_to_integer
      <span class="type">xx</span>   exit
      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> digital_string_to_integer, negate
      <span class="type">xx</span> exit


   <span class="function-name">sum$digital_string_to_integer</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   <span class="function-name">counter$digital_string_to_integer</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   define_function <span class="string">"digital-string-&gt;integer"</span>, digital_string_to_integer
      <span class="comment">;; &lt;&lt; string[address, length] -- integer &gt;&gt;
</span>      <span class="type">xx</span> zero, literal, sum$digital_string_to_integer, save
      <span class="type">xx</span> zero, literal, counter$digital_string_to_integer, save

      <span class="type">xx</span> dup2, string_reverse!
      <span class="type">xx</span>   help__digital_string_to_integer
      <span class="type">xx</span> string_reverse!, drop2

      <span class="type">xx</span> literal, sum$digital_string_to_integer, fetch
      <span class="type">xx</span> exit

   define_function <span class="string">"help,digital-string-&gt;integer"</span>, help__digital_string_to_integer
      <span class="comment">;; &lt;&lt; reversed-string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   exit

      <span class="type">xx</span> dup2, string_head__char, char_to_decimal_digital
      <span class="type">xx</span>   literal, <span class="constant">10</span>
      <span class="type">xx</span>   literal, counter$digital_string_to_integer, fetch
      <span class="type">xx</span>     one
      <span class="type">xx</span>     literal, counter$digital_string_to_integer
      <span class="type">xx</span>     add_save
      <span class="type">xx</span>   power
      <span class="type">xx</span> multiple

      <span class="type">xx</span> literal, sum$digital_string_to_integer
      <span class="type">xx</span> add_save

      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> help__digital_string_to_integer
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* word</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** find</span>
   * as find
   * find jo in dictionary by word
     but I simply call it "find"
   * a function whoes name is prefixed by "find"
     maybe fail to find
     and maybe returns a signal
     to inform the function who calls it
   * note that
     the stack-comment would be easy to write
     if one use always return the same number of return-values
     although when failing to find something
     often only the signal as a return-value would be useful
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*first-jo-in-dictionary*"</span>, V__first_jo_in_dictionary
      <span class="type">xx</span> last_jo_in_assembly

   define_function <span class="string">"find"</span>, find
      <span class="comment">;; &lt;&lt; word[address, length] -- jo, found or not &gt;&gt;
</span>      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> help__find
      <span class="type">xx</span> exit

   define_function <span class="string">"help,find"</span>, help__find
      <span class="comment">;; &lt;&lt; word[address, length], jo -- jo, found or not &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, null_jo?, false?branch, <span class="constant">6</span>
      <span class="type">xx</span>   drop, drop2
      <span class="type">xx</span>   false, false
      <span class="type">xx</span>   exit
      <span class="type">xx</span> xxtuckx
      <span class="type">xx</span> jo_to_name, xxoverxx
      <span class="type">xx</span> string_equal?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> xswapxx, jo_to_pre_jo
      <span class="type">xx</span> help__find
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** execute-word</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"execute-word"</span>, execute_word
      <span class="comment">;; &lt;&lt; word[address, length] -- unknown &gt;&gt;
</span>      <span class="type">xx</span> dup2, integer_string?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   string_to_integer
      <span class="type">xx</span>   exit
      <span class="comment">;; maybe more
</span>
      <span class="type">xx</span> dup2 <span class="comment">;; for to report undefined word
</span>
      <span class="type">xx</span> find, false?branch, <span class="constant">5</span>
      <span class="type">xx</span>   xxswapx, drop2
      <span class="type">xx</span>   execute_jo
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop  <span class="comment">;; jo
</span>
      <span class="type">xx</span> write_undefined_word_report
      <span class="type">xx</span> write_string
      <span class="type">xx</span> literal, <span class="constant">10</span>, write_byte
      <span class="type">xx</span> exit

   define_function <span class="string">"write-undefined-word-report"</span>, write_undefined_word_report
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> literal, string$undefined_word_report
      <span class="type">xx</span> literal, length$undefined_word_report
      <span class="type">xx</span> write_string
      <span class="type">xx</span> exit

   <span class="function-name">string$undefined_word_report</span>:
      <span class="type">db</span> <span class="string">"   UNDEFINED-WORD : "</span>
   <span class="function-name">.end</span>:
   length$undefined_word_report = (.end - string$undefined_word_report)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * one should use space-string? to make sure
     that the string is not space-string
     before apply string-[head|tail],word onto the string
<span class="org-level-2">** space-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"space-string?"</span>, space_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   exit
      <span class="type">xx</span> over, fetch_byte, space_char?, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   string_tail__char
      <span class="type">xx</span>   digital_string?
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop2, false
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** left-trim,[space-char|non-space-char]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"left-trim,space-char"</span>, left_trim__space_char
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">2</span>
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, string_head__char, space_char?, false?, false?branch, <span class="constant">2</span>
      <span class="type">xx</span>   exit
      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> left_trim__space_char
      <span class="type">xx</span> exit

   define_function <span class="string">"left-trim,non-space-char"</span>, left_trim__non_space_char
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, false?branch, <span class="constant">2</span>
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, string_head__char, space_char?, false?branch, <span class="constant">2</span>
      <span class="type">xx</span>   exit
      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> left_trim__non_space_char
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-[head|tail],word</span>
   * note that
     the following functions do not create new strings
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-head,word"</span>, string_head__word
      <span class="comment">;; &lt;&lt; string[address, length] -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> left_trim__space_char
      <span class="type">xx</span> dup2, left_trim__non_space_char
      <span class="type">xx</span> swap, drop
      <span class="type">xx</span> subtraction
      <span class="type">xx</span> exit

   define_function <span class="string">"string-tail,word"</span>, string_tail__word
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> left_trim__space_char
      <span class="type">xx</span> left_trim__non_space_char
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** exit-word?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">string$exit_word</span>:
      <span class="type">db</span> <span class="string">"exit"</span>
   <span class="function-name">.end</span>:
   length$exit_word = (.end - string$exit_word)

   define_function <span class="string">"exit-word?"</span>, exit_word?
      <span class="comment">;; &lt;&lt; word[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> literal, string$exit_word
      <span class="type">xx</span> literal, length$exit_word
      <span class="type">xx</span> string_equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* basic-REPL</span>
<span class="org-block-begin-line">  #+begin_src fasm :tangle cicada-nymph.fasm
</span>  define_function <span class="string">"basic-REPL"</span>, basic_REPL
     <span class="comment">;; &lt;&lt; unknown -- unknown &gt;&gt;
</span>     <span class="type">xx</span> read_word_for_REPL
     <span class="type">xx</span> execute_word
     <span class="type">xx</span> basic_REPL
     <span class="type">xx</span> exit
<span class="org-block-end-line">  #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* : &amp; ;</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * from the aesthetics point of view
     I do NOT think which of the following is better then the other
     but I choose the second one
   * first:
<span class="org-block-begin-line">     #+begin_src
</span><span class="org-block">     define-function factorial
       &lt;&lt; n -- n! &gt;&gt;
       dup one? if
         exit
       then
       dup sub1 factorial *
       exit
     end
</span><span class="org-block-end-line">     #+end_src
</span>   * second:
<span class="org-block-begin-line">     #+begin_src cicada-nymph
</span>     <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">factorial</span>
       <span class="cicada-nymph-comment">&lt;&lt; n -- n! &gt;&gt;</span>
       dup one? <span class="cicada-nymph-syntax-key-word">if</span>
         <span class="cicada-nymph-exit">exit</span>
       <span class="cicada-nymph-syntax-key-word">then</span>
       dup sub1 factorial *
       <span class="cicada-nymph-exit">exit</span>
     <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
<span class="org-block-end-line">     #+end_src
</span><span class="org-level-2">** [colon|semicolon]-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"colon-string?"</span>, colon_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> literal, <span class="default">':'</span>, char_string?
      <span class="type">xx</span> exit

   define_function <span class="string">"semicolon-string?"</span>, semicolon_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> literal, <span class="default">';'</span>, char_string?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** comment-[begin|end]-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">string$comment_begin</span>:
      <span class="type">db</span> <span class="string">"&lt;&lt;"</span>

   define_function <span class="string">"comment-begin-string?"</span>, comment_begin_string?
      <span class="comment">;; (* string[address, length] -- bool *)
</span>      <span class="type">xx</span> literal, string$comment_begin
      <span class="type">xx</span> literal, <span class="constant">2</span>
      <span class="type">xx</span> string_equal?
      <span class="type">xx</span> exit


   <span class="function-name">string$comment_end</span>:
      <span class="type">db</span> <span class="string">"&gt;&gt;"</span>

   define_function <span class="string">"comment-end-string?"</span>, comment_end_string?
      <span class="comment">;; (* -- *)
</span>      <span class="type">xx</span> literal, string$comment_end
      <span class="type">xx</span> literal, <span class="constant">2</span>
      <span class="type">xx</span> string_equal?
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** colon &amp; semicolon</span>
   * nested : ; is not allow
     and no error check for it
   * nested &lt;&lt; &gt;&gt; must be handled
   * comment are handled by : ;
     comment inside : ; are not readed
   * note that
     there might be a ; in &lt;&lt; &gt;&gt;
     when this happens
     the ; must NOT be readed
   * note that
     a bar-ket is readed as a word
     but "&lt;" &amp; "&gt;" are not viewed as bar-ket
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   buffer$colon <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span> * <span class="constant">1024</span>

   <span class="function-name">cursor$colon</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   define_function <span class="string">":"</span>, colon
      <span class="comment">;; &lt;&lt; -- string[address of buffer$colon, length] &gt;&gt;
</span>      <span class="type">xx</span> literal, buffer$colon
      <span class="type">xx</span> literal, cursor$colon, save

      <span class="type">xx</span> help__loop__colon

      <span class="type">xx</span> literal, buffer$colon
      <span class="type">xx</span> literal, cursor$colon, fetch
      <span class="type">xx</span> literal, buffer$colon
      <span class="type">xx</span> subtraction
      <span class="type">xx</span> exit


   define_function <span class="string">"help,loop,colon"</span>, help__loop__colon
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> read_word
      <span class="type">xx</span> dup2, semicolon_string?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, comment_begin_string?, false?branch, <span class="constant">5</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   ignore_comment
      <span class="type">xx</span>   help__loop__colon
      <span class="type">xx</span>   exit
      <span class="type">xx</span> help__add__colon
      <span class="type">xx</span> help__loop__colon
      <span class="type">xx</span> exit


   <span class="comment">;; when add a word into buffer
</span>   <span class="comment">;; tail it with a space
</span>   define_function <span class="string">"help,add,colon"</span>, help__add__colon
      <span class="comment">;; &lt;&lt; word[address, length] -- &gt;&gt;
</span>      <span class="comment">;; &lt;* word[address, length] -- *&gt;
</span>      <span class="comment">;; &lt;&lt; word[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> tuck
      <span class="type">xx</span>   literal, cursor$colon, fetch
      <span class="type">xx</span>   string_to_buffer!
      <span class="type">xx</span> literal, cursor$colon, add_save
      <span class="type">xx</span> one
      <span class="type">xx</span>   literal, <span class="constant">32</span>
      <span class="type">xx</span>   literal, cursor$colon, fetch
      <span class="type">xx</span>   save_byte
      <span class="type">xx</span> literal, cursor$colon, add_save
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ignore-comment</span>
   * this function is for basic-REPL
     but it is reused by colon
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"&lt;&lt;"</span>, ignore_comment
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> read_word
      <span class="type">xx</span> dup2, comment_begin_string?, false?branch, <span class="constant">5</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>     ignore_comment <span class="comment">;; for the new nested-comment
</span>      <span class="type">xx</span>   ignore_comment <span class="comment">;; for the rest-comment
</span>      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, comment_end_string?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop2
      <span class="type">xx</span> ignore_comment
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src cicada-nymph
</span>   <span class="cicada-nymph-number">1</span> <span class="cicada-nymph-comment">&lt;&lt; 989 &gt;&gt;</span> <span class="cicada-nymph-number">64</span> add .
   <span class="cicada-nymph-comment">&lt;&lt; 65 &gt;&gt;</span>

   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">kkk</span> <span class="cicada-nymph-comment">&lt;&lt; 989 &lt;&lt; 989 &gt;&gt;</span> &gt;&gt; <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">.s</span>
   <span class="cicada-nymph-comment">&lt;&lt; kkk &gt;&gt;</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* </span><span class="org-todo">&gt;&lt;</span><span class="org-level-1"> function &amp; jojo</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   address$jo_heap <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">3</span> * <span class="constant">1024</span> * <span class="constant">1024</span> * bead_size

   define_variable <span class="string">"*current-free-address,jo-heap*"</span>, V__current_free_address__jo_heap
      <span class="type">xx</span> address$jo_heap
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * the make-jojo is a macro dispatcher
     it can be viewed as make-function-body
     it gets next word and use predicates on word to do dispatch
   * note that
     make-jojo can be viewed as the "compiler" of the cicada-nymph
     it does NOT (can not) compile file to file
     but creates structured data directly into memory
<span class="org-level-2">** make-jojo</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"make-jojo"</span>, make_jojo
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> dup2, space_string?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_tail__word
      <span class="type">xx</span> xxswapxx
      <span class="type">xx</span> string_head__word
      <span class="comment">;; &lt;&lt; tail[address, length], head[address, length] &gt;&gt;
</span>      <span class="type">xx</span> make_jojo__dispatch_word
      <span class="type">xx</span> make_jojo
      <span class="type">xx</span> exit

   define_function <span class="string">"make-jojo,dispatch-word"</span>, make_jojo__dispatch_word
      <span class="comment">;; &lt;&lt; string[address, length], word[address, length] --
</span>      <span class="comment">;;    string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> dup2, exit_word?, false?branch, <span class="constant">5</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   zero
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, zero_string?, false?branch, <span class="constant">6</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   literal, zero
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2, integer_string?, false?branch, <span class="constant">7</span>
      <span class="type">xx</span>   literal, literal
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   string_to_integer
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> dup2
      <span class="type">xx</span> find, false?, false?branch, <span class="constant">8</span>
      <span class="type">xx</span>   drop <span class="comment">;; jo
</span>      <span class="type">xx</span>   write_undefined_word_report__for_funtion_body
      <span class="type">xx</span>   write_string
      <span class="type">xx</span>   literal, <span class="constant">10</span>, write_byte
      <span class="comment">;;   &gt;&lt;&gt;&lt;&gt;&lt;
</span>      <span class="comment">;;   here we should not compile the function into memory at all
</span>      <span class="comment">;;   note that
</span>      <span class="comment">;;     proper exception handling
</span>      <span class="comment">;;     can be implemented by doing side-effect on return-stack
</span>      <span class="type">xx</span>   !kkk
      <span class="comment">;; xx   exit
</span>      <span class="type">xx</span> xxswapx, drop2 <span class="comment">;; word
</span>      <span class="type">xx</span> make_jojo__dispatch_jo
      <span class="type">xx</span> exit

   define_function <span class="string">"make-jojo,dispatch-jo"</span>, make_jojo__dispatch_jo
      <span class="comment">;; &lt;&lt; string[address, length], jo --
</span>      <span class="comment">;;    string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, function_jo?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, primitive_function_jo?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, variable_jo?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span>   exit
      <span class="type">xx</span> <span class="keyword">dup</span>, macro_jo?, false?branch, <span class="constant">3</span>
      <span class="type">xx</span>   execute_jo
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop
      <span class="type">xx</span> exit

   define_function <span class="string">"write-undefined-word-report,for-funtion-body"</span>, write_undefined_word_report__for_funtion_body
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> literal, string$undefined_word_report__for_funtion_body
      <span class="type">xx</span> literal, length$undefined_word_report__for_funtion_body
      <span class="type">xx</span> write_string
      <span class="type">xx</span> exit

   <span class="function-name">string$undefined_word_report__for_funtion_body</span>:
      <span class="type">db</span> <span class="string">"   make-jojo meets UNDEFINED-WORD : "</span>
   <span class="function-name">.end</span>:
   length$undefined_word_report__for_funtion_body = (.end - string$undefined_word_report__for_funtion_body)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> macro in cicada-nymph</span>
   * a macro is a function to be called at compile time
     with a string to be compiled as one argument
     and do side-effect to store data into memory
     and return a shorter string
     [this can be viewed as moving a cursor forward]
   * a macro should be highlight by text editor in a special way
<span class="org-level-2">** address</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_macro <span class="string">"address"</span>, M__address
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> literal, address
      <span class="type">xx</span> save_into__jo_heap

      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_head__word
      <span class="type">xx</span> find, false?branch, <span class="constant">4</span>
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span>   string_tail__word
      <span class="type">xx</span>   exit
      <span class="type">xx</span> drop

      <span class="type">xx</span> dup2
      <span class="type">xx</span> write_undefined_word_report__for_funtion_body
      <span class="type">xx</span> string_head__word, write_string
      <span class="type">xx</span> literal, <span class="constant">10</span>, write_byte
      <span class="comment">;; &gt;&lt;&gt;&lt;&gt;&lt;
</span>      <span class="comment">;; here we should not compile the function into memory at all
</span>      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">&gt;&lt;</span><span class="org-level-2"> branch</span>
<span class="org-level-2">** </span><span class="org-todo">&gt;&lt;</span><span class="org-level-2"> false?branch</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * for the following function
     I add the "CICADA__" as prefix
     to distinguish from their assembly code version
<span class="org-level-2">** !kkk</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_exception <span class="string">"!kkk"</span>, !kkk
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> write_string
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** define-function</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"define-function"</span>, CICADA__define_function
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> prepare_for
      <span class="type">xx</span>   exception_head
      <span class="type">xx</span>   !kkk
      <span class="type">xx</span>   exit


      <span class="type">xx</span> dup2

      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> string_head__word
      <span class="type">xx</span>   save_into__primitive_string_heap

      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> address, V__first_jo_in_dictionary
      <span class="type">xx</span> save

      <span class="type">xx</span> literal, explain$function
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> dup2, string_tail__word
      <span class="type">xx</span>   make_jojo

      <span class="comment">;; when debugging
</span>      <span class="comment">;; instead of drop2
</span>      <span class="comment">;; one may wish to do some thing to the string
</span>      <span class="type">xx</span> drop2
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src cicada-nymph
</span>   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">addadd</span> add add <span class="cicada-nymph-exit">exit</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> <span class="cicada-nymph-number">2</span> <span class="cicada-nymph-number">3</span> addadd . <span class="cicada-nymph-comment">&lt;&lt; 6 &gt;&gt;</span>

   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">add1</span> <span class="cicada-nymph-number">1</span> add <span class="cicada-nymph-exit">exit</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> add1 . <span class="cicada-nymph-comment">&lt;&lt; 2 &gt;&gt;</span>

   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">negate</span> <span class="cicada-nymph-number">0</span> swap sub <span class="cicada-nymph-exit">exit</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> negate . <span class="cicada-nymph-comment">&lt;&lt; -1 &gt;&gt;</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** define-macro</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"define-macro"</span>, CICADA__define_macro
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> dup2

      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> string_head__word
      <span class="type">xx</span>   save_into__primitive_string_heap

      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> address, V__first_jo_in_dictionary
      <span class="type">xx</span> save

      <span class="type">xx</span> literal, explain$macro
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> dup2, string_tail__word
      <span class="type">xx</span>   make_jojo

      <span class="comment">;; when debugging
</span>      <span class="comment">;; instead of drop2
</span>      <span class="comment">;; one may wish to do some thing to the string
</span>      <span class="type">xx</span> drop2
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** define-variable</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"define-variable"</span>, CICADA__define_variable
      <span class="comment">;; &lt;&lt; variable, string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> dup2

      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> string_head__word
      <span class="type">xx</span>   save_into__primitive_string_heap

      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> address, V__first_jo_in_dictionary
      <span class="type">xx</span> save

      <span class="type">xx</span> literal, explain$variable
      <span class="type">xx</span>   save_into__jo_heap

      <span class="comment">;; when debugging
</span>      <span class="comment">;; instead of drop2
</span>      <span class="comment">;; one may wish to do some thing to the string
</span>      <span class="type">xx</span> drop2
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * you can see how the naming convention is used
     for functions that create structured data into memory
<span class="org-level-2">** save-into,primitive-string-heap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"save-into,primitive-string-heap"</span>, save_into__primitive_string_heap
      <span class="comment">;; &lt;&lt; string[address, length] -- address &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, V__current_free_address__primitive_string
      <span class="type">xx</span> save_two_bytes

      <span class="type">xx</span> literal, <span class="constant">2</span>
      <span class="type">xx</span> address, V__current_free_address__primitive_string
      <span class="type">xx</span> add_save

      <span class="type">xx</span> tuck
      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span> string_to_buffer!

      <span class="type">xx</span> address, V__current_free_address__primitive_string
      <span class="type">xx</span> add_save

      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** save-into,jo-heap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"save-into,jo-heap"</span>, save_into__jo_heap
      <span class="comment">;; &lt;&lt; number -- address &gt;&gt;
</span>      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> save

      <span class="type">xx</span> literal, bead_size
      <span class="type">xx</span> address, V__current_free_address__jo_heap
      <span class="type">xx</span> add_save

      <span class="type">xx</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src cicada-nymph
</span>   <span class="cicada-nymph-number">233</span> <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">*three*</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-variable</span>
   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">add-three</span> <span class="cicada-nymph-variable">*three*</span> add <span class="cicada-nymph-exit">exit</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> add-three . <span class="cicada-nymph-comment">&lt;&lt; 234 &gt;&gt;</span>

   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">fix-*three*</span> <span class="cicada-nymph-number">3</span> <span class="cicada-nymph-syntax-key-word">address</span> <span class="cicada-nymph-variable">*three*</span> save <span class="cicada-nymph-exit">exit</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   fix-*three*
   <span class="cicada-nymph-number">1</span> add-three . <span class="cicada-nymph-comment">&lt;&lt; 4 &gt;&gt;</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* epilog</span>
<span class="org-level-2">** last_jo_in_assembly</span>
   * this word helps to initialize V__first_jo_in_dictionary
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">""</span>, last_jo_in_assembly
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="constant">0</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-level-2"><span class="bold">*current-free-address,primitive-string-heap*</span></span>
   * the last_primitive_string_in_assembly
     is just "<span class="bold">*current-free-address,primitive-string-heap*</span>"
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*current-free-address,primitive-string-heap*"</span>, V__current_free_address__primitive_string
      <span class="type">xx</span> current_free_address$primitive_string_heap
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** un_initialized_memory</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   size$un_initialized_memory = <span class="constant">64</span> * <span class="constant">1024</span> * <span class="constant">1024</span> <span class="comment">;; (byte)
</span>
   <span class="keyword">segment</span> <span class="keyword">readable</span> <span class="keyword">writeable</span>
   <span class="function-name">address$un_initialized_memory</span>:
      <span class="type">rb</span> size$un_initialized_memory
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* ===================================</span>
</pre>
  </body>
</html>
