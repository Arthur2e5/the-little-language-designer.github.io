
layout: post
title: 棧機 與 棧機中函數語義
description: "於是 我理解了機器之心"
imagefeature: "tanna-japonensis-2.jpg"
categories:
  - documentations


警告
=================
請不要閱讀這個文本 因爲 對你而言 其中 可能包含解釋不充分的概念和術語
這個文本是我爲了 教我的朋友我的語言的實現技術而寫的 他們有就文本細節跟我形成問答的機會

題解
=================
我把很多術語按我的理解中文化了 因爲英文的術語非常糟糕

1. 棧機: Forth 虛擬機 或 Forth 內部解釋器 (Forth inner interpreter) 或 線程碼解釋器(threaded code interpreter)
   請忽略這些英文術語直接說 棧機
2. 函數語義: 指機器處理函數的方式

人可以 直接造一個芯片來實現一個 棧機
但是通常 人需要在其他類型的芯片上 以虛擬化的方式 實現 棧機
這個文本正是要介紹 怎麼在其他類型的芯片上 以各種方式實現棧機 並且 讓這個棧機能夠處理函數

這個文本的內容來源於我對 我的 類 Forth 語言 cicada 的實現技術的總結
但是 Forth 這個詞 將並不經常出現在 這個文本之中
因爲 Forth 社區中的朋友向我指出 用 Forth 來稱呼 所有與它類似的語言
會混淆人們對 Forth本身作爲一個語言 的理解

簡介
==================
1. 最底層的部分是
   一個用 匯編語言中所提供的宏 所寫成的 棧虛擬機
   *當有編譯器時 這一部分的實現方式將被重新設計*
   這一部分 在沒有對輸入輸出的處理的情況下 也能獨立成器
   此時它可以被看成是一種寫匯編代碼的風格
   以這種方式寫的匯編代碼和蟬語中的函數定義有 簡單的 相對線性的 對應關係
2. 在這種 匯編代碼中 需要實現
   1. 對輸入輸出的處理
   2. 詞典編撰者
3. 蟬語的其餘部分用蟬語寫成
   *當有編譯器時 蟬語的所有部分都將用蟬語寫成*

間接
==================
1. 這是 蟬語所使用的 實現棧機的方式
   這是 最古典的實現方式 其他的方式都衍生於此
2. 字典中 *詞* 這個數據結構中所包含的某些數據
   與實現棧機之函數語義有關
   - 下面以 *詞之* 爲前綴者
     皆爲 *詞* 這個數據結構中間的某個位置的地址
   - *詞之詮釋者*
     爲一個一元數組 其中保存一個 *詮釋者*
   - *詮釋者*
     是一個值 這個值 是一段匯編代碼的地址
     目前只有兩個 一個爲詮釋動詞 一個爲詮釋動詞
   - *詞之定義*
     爲一個數組 其中保存用來描述這個詞的定義的 每個詞的 *詞之詮釋者*
3. 有了數據結構
   爲了實現 棧機的函數語義
   再需要的就只是 處理 *詞* 這個數據結構的函數
   - 首先 每個 *詮釋者* 本身就是一個處理 *詞* 這個數據結構的函數
     而 *原子詞* 沒有詮釋者
     其定義內所包含的 不是 用來描述這個詞的定義的其他的詞
     而是 一段匯編代碼
     其數據結構中 本來應該保存詮釋者的位置 所保存的正是 這段匯編代碼的地址
   - 每個 *詮釋者* 也是一段匯編代碼
     蟬語的棧機中的所有的匯編代碼就只有兩種 一類爲 詮釋者的匯編代碼 二類爲 原子性的詞的匯編代碼
     只有這些代碼是真正被處理器執行的
   - 當一 *詮釋者* 被執行的時候
     rax 這個寄存器中保存的都是 這個詮釋者 所應詮釋的詞的 *詞之詮釋者*
     蟬語的棧機中 只有這一個地方是依賴與 寄存器對參數的傳遞的
     其他的情況下 都使用 *參數棧* 來傳遞參數
   - *詮釋者* 作爲處理 *詞* 這個數據結構的函數
     需要使用一個 名爲 *返回棧* 的棧
     這是因爲 *詞* 這個數據結構 是一個 *嵌套的數據結構*
     而處理 *嵌套的數據結構* 需要用 *遞歸函數*
     而實現 *遞歸函數* 需要用棧
   - 可以把 *返回棧* 想像成 *一個布條兒*
     這個布條兒上面 可以貼很多 *紙條兒*
     每個紙條兒代表一個非原子性的 *詞之定義* 其數組
     一個紙條兒被貼在布條兒上 就代表了這個函數的函數體正在被執行
     紙條兒以哪個位置被貼在布條兒上 就代表了這個函數體執行到哪兒了
     這個布條兒和紙條兒的裝置 記錄了 在執行完當前的函數之後
     應該返回到哪個函數中 和 應該返回到這個函數中的哪個位置
   - 對非原子性動詞來說
     其詮釋者 會把 其 *詞之定義* 作爲一個紙條兒 貼到布條兒上
     也就是說 詮釋者 做着 *展開遞歸函數* 的工作
     它會增加布條兒上的紙條兒的數量
   - **next** 匯編代碼中的一個宏
     當然 這個宏也可以被實現爲子程
     只不過目前 蟬語的棧機是在用宏來實現它而已
     原子性的詞的匯編代碼 後面都跟着這個宏
     因爲此時一個原子性的詞的匯編代碼已經被執行完畢
     所以這個宏所做的工作是
     去拉動布條兒上的紙條兒
     並且當一個紙條兒被拉到頭時
     把這個紙條兒從布條兒上取下來
     也就是說 這個宏 做着 *收斂遞歸函數* 的工作
     它會 改變條兒上的紙條兒的位置
     或 減少布條兒上的紙條兒的數量
4. 如上就是蟬語的棧機的基本工作方式了
   本質上重要的東西都在這裏了
   只是還有一些與語法關鍵詞有關的細節沒有被介紹

衍生
==================
1. 上面以節的題目之所以叫做 *間接*
   就在於 其中 布條兒上最前面的紙條
   即 *返回棧* 的棧頂
   好似是被當作 虛擬機的 *指令指針* 來使用的
   這是一種間接的處理方式
   因爲要知道用來實現 棧虛擬機 的處理器本身已經有自己的 *指令指針* 了
2. 這種實現方式的特點是
   它對用來實現棧虛擬機的處理器的功能的要求最少
   用來實現棧虛擬機的處理器本身
   可以被設計的非常精簡
   它可以沒有關於棧的指令
   它可以沒有關於函數調用的指令
3. 然而
   當處理器本身已經有豐富的功能的時候
   實現棧虛擬機的時候就可以把這些功能利用起來
   比如 如果已經有關於棧的指令了
   那麼就可以直接把 處理器 中的棧用爲 參數棧 或 返回棧
   又比如 如果已經有關於函數調用的指令了
   那麼就可以直接使用 的處理器本身已經有自己的 *指令指針*
   而不再去實現一個虛擬的 *指令解釋器*
4. 蟬語使用最樸素的方式
   這是最靈活的
   在此基礎上 對某些設計決策的變更 是相對容易的
   而針對某個處理器的優化 在需要的時候進行即可
