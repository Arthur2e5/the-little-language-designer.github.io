
本文介紹蟬語的漢語語法的基本部分

# 引
蟬語是 簡單的 以明顯的方式使用棧的 主要支持函數式編程範式的 程序語言.
其設計靈感來源於 Forth 和 Scheme 和 Joy.

# 使用
使用 蟬語 的方法因時境而異,
所以請閱讀 "cicada/READEM.org"
以獲知 相關信息.

# 棧機
蟬語 利用一個 棧虛擬機 來實現函數語義.
在 其解釋器中 將下面的代碼輸入 並以回車結束
你就可以將 1 和 2 相加 並打印出結果 :

<pre>
<span class="cicada-number">1</span> <span class="cicada-number">2</span> + .
</pre>

- *1* : 把 *1* 入參數棧.
- *2* : 把 *2* 入參數棧.
- *+* : 調用 *+* 這個函數,
  它會把 參數棧 頂部的兩個數字拿出來,
  把它們加起來, 並把結果再放到參數棧中.
- *.* : 調用 *.* 這個函數,
  它會把 參數棧 頂部的一個數字拿出來,
  並打印出這個數字.

如果你不知道 在程序設計的語境下 *棧* 是什麼意思,
那就請把 參數棧 想像成是 堆疊在桌子上的一疊卡片,
其特點是 當堆疊起多個卡片時,
先放上去的卡片會被壓在底下,
要等後放上去的卡片被取走之後,
先放上去的卡片才能被取走.

每個卡片上寫着一個數字
至於 *函數* 你可以把它想像成一個個小機器人

- 不同的 *函數* 會以不同的方式來理解並處理這些數字
- 即 這些數字 編碼着信息
- 當 *函數* 被執行時
  小機器人會把這些 編碼了信息的 寫有數字的 卡片 從桌子上拿起來
- 一張一張地 從這疊卡片的頂部開始拿
- 被拿起來的卡片被稱作 *函數的參數*
- 當處理了這些信息 而需要返回一些信息作爲結果的時候
  *函數* 會再把 一些卡片放回到這疊卡片的頂部
- 被放回的卡片被稱作 *函數的返回值*

比如 下面的例子是去計算 10 的平方, 並打印出結果 :
<pre>
<span class="cicada-number">10</span> 復 乘 .
</pre>

- 其中 *復* 是一個函數,
  它會從 那疊卡片的頂部取一張卡片,
  然後 複製一張相同的卡片
  再把兩張卡片都放回到棧的頂部
- 而 *乘* 也是一個函數,
  它從 那疊卡片的頂部取兩張卡片,
  然後 計算這兩張卡片上寫的數字的 乘積,
  然後 把這個乘積寫到一張新的卡片上,
  並把這張新的卡片放回到棧的頂部
- 最後那個 小點兒: "." 也是一個函數,
  它取棧頂的一張卡片,
  並把這個卡片上所寫的數字打印到屏幕上

*棄* *復* *躍* *藏* *換* 是五個基本的用來操作棧的函數
它們分別翻譯於英文的 *drop* *duplicate* *over* *tuck* *swap*

漢語中單個字符所能表達的意義之豐富 非西語所能及也
而這篇介紹 蟬語 的基本語法的文章之題目就叫 *棄* *復* *躍* *藏* *換*
義在表達我對漢語的喜愛

這五個基本函數 *棄* *復* *躍* *藏* *換* 又衍生出 *而棄* *而復* *而躍* *而藏* *而換* 這五個使用起來更靈活的函數

請讀完整篇文章之後再回來看下面這段代碼

<pre>
<span class="cicada-comment">(* &#23531;&#22312;&#36889;&#31278;&#26143;&#24418;&#25324;&#34399;&#20043;&#38291;&#32773;&#29234;&#20195;&#30908;&#20043;&#35387;&#37323; &#23427;&#20497;&#26371;&#34987;&#26855;&#27231;&#24573;&#30053; *)</span>

<span class="cicada-number">1</span> <span class="cicada-number">2</span> <span class="cicada-number">3</span> <span class="cicada-number">4</span> <span class="cicada-number">5</span> <span class="cicada-comment">(* &#23559;&#36889;&#20116;&#20491;&#25976;&#23383;&#25918;&#20837;&#21443;&#25976;&#26855;&#20013; *)</span>

<span class="cicada-number">2</span> <span class="cicada-number">3</span> &#32780;&#34255;

<span class="cicada-comment">(* &#21063;&#21443;&#25976;&#26855;&#20013;&#25976;&#23383;&#23559;&#35722;&#29234;:
 *   3 4 5  1 2  3 4 5
 * &#21363; &#23559;&#26855;&#38914;&#31471;&#30340;&#19977;&#20491;&#25976;&#23383;&#35079;&#35069;&#19968;&#36941;
 * &#20006;&#34255;&#21040; &#20854;&#21521;&#19979;&#30340;&#20841;&#20491;&#25976;&#23383; &#20043;&#24460; *)</span>

<span class="cicada-number">3</span> &#32780;&#26820;

<span class="cicada-comment">(* &#21063;&#21443;&#25976;&#26855;&#20013;&#25976;&#23383;&#23559;&#35722;&#29234;:
 *   3 4 5  1 2
 * &#21363; &#25291;&#26820;&#26855;&#38914;&#30340;&#21069;&#19977;&#20491;&#25976;&#23383; *)</span>

<span class="cicada-number">3</span> <span class="cicada-number">2</span> &#32780;&#36493;

<span class="cicada-comment">(* &#21063;&#21443;&#25976;&#26855;&#20013;&#25976;&#23383;&#23559;&#35722;&#29234;:
 *   3 4 5  1 2  3 4 5
 * &#21363; &#23559;&#26855;&#38914;&#31471;&#30340;&#19977;&#20491;&#25976;&#23383;&#35079;&#35069;&#19968;&#36941;
 * &#20006;&#36493;&#36942; &#20854;&#21521;&#19978;&#30340;&#20841;&#20491;&#25976;&#23383; &#32780;&#32622;&#26044;&#26855;&#38914;  *)</span>

<span class="cicada-number">2</span> <span class="cicada-number">3</span> &#32780;&#25563;

<span class="cicada-comment">(* &#21063;&#21443;&#25976;&#26855;&#20013;&#25976;&#23383;&#23559;&#35722;&#29234;:
 *   3 4 5  3 4 5  1 2
 * &#21363; &#23559;&#26855;&#38914;&#31471;&#30340;&#21069;&#20116;&#20491;&#25976;&#23383; &#19977;&#20841;&#20132;&#25563; *)</span>

<span class="cicada-comment">(* &#28982;&#21063; &#26820;&#24489;&#36493;&#34255;&#25563; &#32773; &#20309;&#22914; ? *)</span>

<span class="cicada-sentence-reader">&#22827;</span> <span class="cicada-word-to-define">&#26820;</span>
   <span class="cicada-number">1</span> &#32780;&#26820; <span class="cicada-exit">&#24050;&#30691;</span> <span class="cicada-sentence-reader">&#32773;</span> <span class="cicada-lexicographer">&#21205;&#35422;&#20063;</span>

<span class="cicada-sentence-reader">&#22827;</span> <span class="cicada-word-to-define">&#24489;</span>
   <span class="cicada-number">1</span> &#32780;&#24489; <span class="cicada-exit">&#24050;&#30691;</span> <span class="cicada-sentence-reader">&#32773;</span> <span class="cicada-lexicographer">&#21205;&#35422;&#20063;</span>

<span class="cicada-sentence-reader">&#22827;</span> <span class="cicada-word-to-define">&#36493;</span>
   <span class="cicada-number">1</span> <span class="cicada-number">1</span> &#32780;&#36493; <span class="cicada-exit">&#24050;&#30691;</span> <span class="cicada-sentence-reader">&#32773;</span> <span class="cicada-lexicographer">&#21205;&#35422;&#20063;</span>

<span class="cicada-sentence-reader">&#22827;</span> <span class="cicada-word-to-define">&#34255;</span>
   <span class="cicada-number">1</span> <span class="cicada-number">1</span> &#32780;&#34255; <span class="cicada-exit">&#24050;&#30691;</span> <span class="cicada-sentence-reader">&#32773;</span> <span class="cicada-lexicographer">&#21205;&#35422;&#20063;</span>

<span class="cicada-sentence-reader">&#22827;</span> <span class="cicada-word-to-define">&#25563;</span>
   <span class="cicada-number">1</span> <span class="cicada-number">1</span> &#32780;&#25563; <span class="cicada-exit">&#24050;&#30691;</span> <span class="cicada-sentence-reader">&#32773;</span> <span class="cicada-lexicographer">&#21205;&#35422;&#20063;</span></pre>


# 詞典之喻
在設計和實現這個程序語言的時候,
我系統地使用了 一種 *詞典比喻*.
欲用語言學中的某些術語來 捕捉程序設計中的某些概念.
*函數* 也被稱作是 *動詞*, *變量* 也被稱作是 *名詞*,
而語言中的 *語法關鍵詞* 也被我稱作是 *虛詞*.

編程是爲了寫出代碼來指示機器,
以使其幫助編程者解決所預解決之問題 (幫助編程者完成大量枯燥的腦力勞動),
在 *詞典比喻* 下, 編程的過程變成了這樣 :

1. 思考所欲解決之問題.
2. 設計出一些 *名詞* *動詞* *虛詞* 來描述其問題.
3. 把這些詞定義出來, 並把它們編撰到詞典中.
4. 利用你所編撰到詞典中的詞,
   寫一段簡短的文字來解決所感興趣的問題.

定義一個新的詞時 所使用的必須是已經編撰到詞典中了的詞,
或是 將要被編撰到詞典中的詞;
而當一個新詞被編撰到詞典中之後,
你就可以使用它來定義別的詞了.

我 和 我的朋友 **鮑鴻然** 想到了,
我們可以仿照文言中的一種陳述句的句式來表達對詞典的編撰,
比如, 爲了把上面的計算平方的那段代碼 作爲一個名叫 *計算平方* 的動詞的定義, 並且把這個動詞編撰到詞典中, 我可以這樣寫 :

<pre>
<span class="cicada-sentence-reader">夫</span> <span class="cicada-word-to-define">計算平方</span>
   復 乘 . <span class="cicada-exit">已矣</span> <span class="cicada-sentence-reader">者</span>  <span class="cicada-lexicographer">動詞也</span>
</pre>

- 其中 *夫* 標誌着一個陳述句的開端;
- *夫* 後面緊跟着的一個詞是 *被定義之詞* (這裏的 *計算平方*);
- 而 *者* 標誌着一個陳述句的結束;
  而處在其間者 就是對 *被定義之詞* 的定義 (這裏的 *復* *乘* *.* *已矣*),
  即 這個函數的函數體;
- 而 *已矣* 是一個特殊的詞,
  它標誌着需要在函數體的什麼位置退出 對這個函數的調用;
- 而像 *動詞也* 這種詞, 我把它們稱爲是 *詞典編撰者*,
  前面的 *夫* 與 *者* 已經形成了一個 定義 那個 *被定義之詞* 的陳述句了,
  那麼這裏的 *動詞也* 就可以被看作是 對這個陳述句的補充或加強,
  它會把 它前面的陳述句編撰到詞典中.



比如下面的這段代碼 會調用剛才定義的函數 它的效果和之前的代碼的效果相同 :

<pre>
<span class="cicada-number">10</span> 計算平方
</pre>

又比如, 爲了把 *10* 作爲一個名叫 *十* 的名詞的定義, 並且把這個名詞編撰到詞典中, 我可以這樣寫 :

<pre>
<span class="cicada-sentence-reader">夫</span> <span class="cicada-word-to-define">十</span> <span class="cicada-number">10</span> <span class="cicada-sentence-reader">者</span> <span class="cicada-lexicographer">也</span>
</pre>

其中 *也* 與 *動詞也* 類似,
都被我稱作是 *詞典編撰者*,
只不過區別是 *也* 所編撰的是一個 *名詞*, 而非 *動詞*.

下面的這段代碼 使用所定義的 名詞 :

<pre>
十 計算平方
</pre>

# 理解
其實只要理解了兩個要點之後你就理解了蟬語的核心部分了,
而後去理解蟬語的其他部分就易如反掌了,
這兩個要點是 :

1. 棧機的工作方式.
2. 定義函數方式,
   即 定義動詞的方式.

你所再需要知道的 就只是 基本的詞典中還有什麼詞能夠爲你所用而已.
而這些知識 可以在實踐中, 或在瀏覽已有的代碼的過程中 輕易地獲得.

# 關於條件句的虛詞
下面我就通過定義一個遞歸函數來向你展示如何使用 *則* 和 *再* 這一對兒基本的 關於條件句的虛詞 :

<pre>
<span class="cicada-sentence-reader">夫</span> <span class="cicada-word-to-define">階乘</span>
   復 一乎 <span class="cicada-syntax-key-word">則</span> <span class="cicada-exit">已矣</span>
   <span class="cicada-syntax-key-word">再</span> 復 <span class="cicada-number">1</span> 減 階乘 乘 <span class="cicada-exit">已矣</span>  <span class="cicada-sentence-reader">者</span> <span class="cicada-lexicographer">動詞也</span>


<span class="cicada-comment">(* 測試: *)</span>

<span class="cicada-number">1</span> 階乘 .
<span class="cicada-number">2</span> 階乘 .
<span class="cicada-number">3</span> 階乘 .
</pre>

1. 你可以發現 因爲在蟬語中 我是以明顯的方式來使用 參數棧的,
   所以 你能以很具體的方式來理解遞歸函數的實現方式.
2. *一乎* 是一個謂詞,
   即 一個返回 *真* 或 *假* 的函數,
   在蟬語中 *1* 就代表 *真*, 而 *0* 就代表 *假*,
   這就是前面所說的 用數字來對信息編碼.
3. *則* 是一個 *虛詞* 或者 *語法關鍵詞*,
   它會取棧頂的值,
   - 如果這個值 是 *真*, 它則執行 *則* 和 *再* 之間的部分, 然後再執行 *再* 之後的部分;
   - 如果這個值 是 *假*, 它轉而執行 *再* 之後的部分;
4. 你可以自己試着一步一步地檢驗一下,
   當 *階乘* 這個函數作用於某些小的參數的時候,
   棧機是如何運行的,
   你會發現 以這樣的方式
   你就能學會遞歸函數是如何用棧來實現的了.

#尾聲
本文只介紹 蟬語 的基本部分,
這是最本質的部分.
我將會寫更多的文檔來介紹 其他有趣的部分,
並將會介紹 實現 這個語言的基本技術,
我保證其他的部分不會比這裏所介紹的更難.
在我看來 難於理解的東西 要麼是設計的不好,
要麼是 沒有得到良好地介紹,
我希望 蟬語 是設計良好的 並且 被細心地介紹的.
如有不明之處 請聯繫我 我將改進.

------------------------------------

Cicada is a very simple programming language.
It is a stack-based and functional language.
The design of cicada is influenced by Scheme and Forth and Joy.

# build and run
The way to build cicada maybe change by time and platforms,
So, please read "cicada/READEM.org" to build it.

When you are running it, you are in an interpreter.
If you want to calculate the sum of 1 and 2, and print the result,
you can type the following to the interpreter.
(of course, end the type by a "enter" or "carry return")

cicada will do the following :


<pre>
<span class="cicada-number">1</span> <span class="cicada-number">2</span> + .
</pre>

  1. when meet the word "1", push 1 to the ArgumtStack.
     (ArgumtStack denotes argument stack)
  2. when meet the word "2", push 2 to the ArgumtStack.
  3. when meet the word "+", call the function "+",
     it will pop two numbers from the ArgumtStack,
     and add them, and push the result to the ArgumtStack.
  4. when meet the word ".", call the function ".",
     it will pop one number from the ArgumtStack,
     and print this number.

If you do not know, in the context of programming, what a stack is,
please think of the ArgumtStack as a stack of cards placed on a desk,
and there is a number (64-bits fixnum) writed on each card.
(different functions could understand a number in different ways,
 this is called information encoding)
when you push a number to the ArgumtStack,
you just place a new card on top of the stack of cards.
when you pop a number from the ArgumtStack,
you just pick up a card from the top of the stack of cards.

here is another example that calculate the square of 10, and print the result.

<pre>
<span class="cicada-number">10</span> dup * .
</pre>

where "dup" is a function that duplicates the top of the ArgumtStack.


we can define "square" as a function
by type the following code into cicada interpreter :

<pre>
<span class="cicada-sentence-reader">:</span> <span class="cicada-word-to-define">square</span>               <span class="cicada-comment">(* after a colon is a function name *)</span>
  <span class="cicada-comment">(* n -- n*n *)</span>       <span class="cicada-comment">(* comment of function type by arguments and results *)</span>
  dup *                <span class="cicada-comment">(* function body *)</span>
  <span class="cicada-exit">Exit</span>
<span class="cicada-sentence-reader">;</span> <span class="cicada-lexicographer">define-function</span>      <span class="cicada-comment">(* after a semicolon is a function we use to define the new function *)</span>
                       <span class="cicada-comment">(* in this example,
                          "define-function" is the function we use
                          to define the new function *)</span>
</pre>

and call it :

<pre>
<span class="cicada-number">10</span> square .
</pre>


# what is a REPL ?
  In LIPS culture, a toplevel interpreter
  is called a "REPL" (read–eval–print loop).
  Yet in cicada, this interpreter is a read-execute loop :

  1. no "print", because the result of an execution (or a call) of a function
     is stored in the "ArgumtStack", but not be printed directly.
  2. the difference between "eval" and "execute"
     is that "eval" requires syntax-analysis (or parsing),
     but "execute" does not.
  3. you will understand these technical differences better
     when you finish reading this intro.

  The following is the source code of the default "symbol-REPL" I used :

<pre>
<span class="cicada-sentence-reader">:</span> <span class="cicada-word-to-define">symbol-REPL</span>                 <span class="cicada-comment">(* after a colon is a function name *)</span>
  <span class="cicada-comment">(* unknown -- unknown *)</span>    <span class="cicada-comment">(* comment of function type by arguments and results *)</span>
  read-word-for-runtime       <span class="cicada-comment">(* function body *)</span>
  execute-word
  symbol-REPL
  <span class="cicada-exit">Exit</span>
<span class="cicada-sentence-reader">;</span> <span class="cicada-lexicographer">define-function</span>             <span class="cicada-comment">(* after a semicolon is a function we use to define the new function *)</span>
                              <span class="cicada-comment">(* in this example,
                                 "define-function" is the function we use
                                 to define the new function *)</span>
</pre>


  1. literally, you can see it is a read-execute loop,
     which is defined as a recursive function.
  2. the recursive call is at the end of the function body,
     (i.e. "symbol-REPL" call itself before "Exit")
     this kind of function call are called "tail call",
     and this kind of recursive function are called "tail recursive function".
     a tail recursive function will be executed by cicada as a loop,
     (this is the so called "tail-call-optimization")
  3. you can see the hard parts of the implementation of this function
     are hided in "execute-word" and "read-word-for-runtime",
     to define this function is simply to form a loop.
  4. By redefining part of a function body as a new function,
     you can make a function definition very readable.
     In Forth culture, this is called "factoring",
     just like separate a big number into factors.
  5. By refactoring a function,
     you can change your understanding of a function.
  6. note that, this REPL does NOT print a prompt like ">" or ":"
     to remind the user that the last things
     that he or she had typed into the interpreter
     had been interpreted successfully,
     and the interpreter is waiting for the next things.
     if you want to know whether the last things had been interpreted successfully,
     you can type "ok" to the interpreter,
     it would print back "yes".
  7. if you think my REPL is odd or unusual,
     feel free to design you own one.

  Believe it or not, if you can understand the above
  you have already mastered the essence of cicada.
  In the following text, I will show you :

  1. more primitive-functions
     that you can use to define new functions.
  2. more examples of function definitions.
  3. the way to define constants and variables.
  4. some of my understanding of a few concepts of programming.

  you can have a rest here,
  for you have learned a new programming language ^_^.

# "if" and "then"
  let me define a non tail recursive function,
  and show you how to use "if" and "then".

<pre>
<span class="cicada-sentence-reader">:</span> <span class="cicada-word-to-define">factorial</span> <span class="cicada-comment">(* n -- n! *)</span>
  dup one? <span class="cicada-syntax-key-word">if</span>
    <span class="cicada-exit">Exit</span>
  <span class="cicada-syntax-key-word">then</span>
  dup sub1 factorial * <span class="cicada-exit">Exit</span>
<span class="cicada-sentence-reader">;</span> <span class="cicada-lexicographer">define-function</span>

<span class="cicada-comment">(* test: *)</span>
<span class="cicada-number">1</span> factorial .
<span class="cicada-number">3</span> factorial .
<span class="cicada-number">12</span> factorial .
</pre>

  1. you will see that by using an explicit ArgumtStack to pass arguments,
     recursive functions can be understanded in a very concrete (or low-level) way.
  2. before going on, you should notice the "syntax" of comment,
     because we use an explicit ArgumtStack to pass arguments,
     the comment of "function type by arguments and results"
     becomes the comment of "how the values in a stack be replaced by new values"
     for example the "function-type" of "sub1" is (* n -- n - 1 * ),
     and the "function-type" of "dup" is (* n -- n, n *),
     note that, if there are many values, they should be separated by commas.
  3. "one?" is a predicate,
     i.e. a function that return the so called boolean value,
     the function-type or the stack-comment of "one?" is (* n -- True or False *),
     in cicada, the two boolean values, True and False, are just 1 and 0.
  4. "if" is a syntax keyword, it introduces you a new way
     to build a big function by smaller functions.
     before you know "if", you can only build a big function by smaller functions
     by function composition,
     i.e. by list smaller functions into the function-body
     of the function definition of the big function.
  5. although "if" is not a function, I can comment it as (* True or False --  *),
     if the argument is True, the part between "if" and "then" will be executed,
     if the argument is False, the part after "then" will be executed.
  6. "factorial" call itself NOT right before "Exit",
     so it is not a tail recursive function.
  7. you can pretend that you are a human interpreter,
     and try to understand how recursive function is implemented
     by observing what happened to the ArgumtStack
     when "3 factorial" is typed into you (the human interpreter).
