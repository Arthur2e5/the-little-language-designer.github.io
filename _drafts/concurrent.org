#+TITLE: note on concurrent
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* 記
  1. inner 解釋器在對函數體做解釋的時候
     可以利用消息傳遞的等待的語義
     把計算分配到不同的處理器上
     一個問題是 等待消息並處理消息的基本單元是 進程
     進程應該如何來實現 ?
  2. 共享某些內存
     此時需要這些內存中的數據具有某種穩定性
  3. 完全不共享內存
     這是不可能的
     比如 我要實現優有向圖處理語言
     有很多函數分工處理有向圖
     如果每次參數傳遞的時候都複製整個有向圖
     那麼計算的時間就都耗費在複製參數上面了
  4. 這基本上說明了
     如果要求語法的一致性[以進行自動的並行化]
     那麼 實現策略 必須是
     在底層實現算法來處理各種情況
  5. 我應該把並行計算的東西放在之後再設計
     因爲 不論是就 有向圖處理 還是就 並行計算 而言
     我的經驗都太少了
* 模型
  1. 設每個函數都是一個獨立的機器 ???
     優自己的堆 ??
* 並行計算
  1. 進程 的特點是 它有自己的棧和堆
     設計上優兩種
     1) 所有的函數都是進程
        所要達到的效果是
        使得一個類似數據分配器的計算分配器
        能夠得以實現
        以在多核時不必讓程序員去管理計算的分配
        這樣就破壞了用棧做參數傳遞的傳統
     2) 進程是函數的集合
  2. 計算分配器 需要完成的任務是什麼 ?
     它像是一個信使
     首先
     可能不是爲了
     把計算任務分配給地球另一邊的一個計算機
     然後在計算之後再收回結算結構
     [儘管這樣是可能的]
     計算分配器 的主要使用場合是
     多核的電腦
     整個電腦整個還被看成是一個整體
     計算分配器 需要把整個電腦的很多處理器的算能力分配出來
     計算分配器 本身也必須佔用一個處理器
     以進行調度工作
     [可能不需要這樣 而去實現完全地對稱]
  3. 它必須能夠部分地模擬串行計算的效果
  4. 那麼
     計算分配器 維護一個列表
     它不停的掃描整個列表
     ><
  5. 把消息傳遞出去之後
     可以等待 被傳遞處的返回
     也可以不等
* pi-calculus
  點之間有一條邊相連時
  它們之間就可以用這條來傳遞信息
  ><><>< 在digrap中如何理解這一點
  ---------------------------------------
  lambda-cal可以被看成是
  在用一種形式語言來描述某種類型的有向圖
  pi-cal更明顯地也可以看成是如此
  ---------------------------------------
  input port & output port
  of the so called agent
  ---------------------------------------
  比如考慮對一個lambda-term的reduce
  顯然我可以把reduction的不同部分的工作分配給不同的cpu
  然後當全算玩之後把結果返回給我
  好讓我作最後的處理以返回最終結果
  ---------------------------------------
  output & input actions
  ---------------------------------------
  有很多的``functional-computer''
  必須能以明顯地控制參數在它們之間的傳遞方式
  讓機器a計算F這個函數
  讓它從機器b和機器c那裏拿參數
  讓它把返回值返回到機器d
  在這個過程中
  機器bc對兩個參數的計算可以是同時進行的
  而機器a必須等待兩個參數都到齊
  參數的傳遞是通過輸入輸出設備來完成的
  ---------------------------------------
  每個機器都有一個獨立的棧
  一個機器可以用自己的棧進行計算
  也可以pop和push 各種port棧
  必須處理``等待''的問題
  即``算好了''這條信息的傳遞的問題
* 有生命的程序 與 並行計算
  * 生命的特點如下
  * body
    即函數體
  * 新陳代謝[metabolism]
    如果每個函數都有自己的堆和棧的話
    那麼其垃圾回收器[數據分配器]之作用
    就像是機器的新陳代謝
    如果嘗試構建類似生物的程序的話
    對內存的消耗就是對主要資源的消耗
  * 前兩個特點的功能是
    movement & replication
  * 遺傳信息[inheritable infomation]
    每個函數作爲有向圖
    其形態中有固定不變的主要部分
    並且有信息幫助初始化一個與其相似的有向圖
  * 加上這個特點
    就能夠遺傳和變異
  * 但是
    自然選擇所對應的是什麼
  * 所以
    把每個函數都做成一個有獨立時間和空間的進程
    是能夠形成很豐富語義的
    爲了分配時間 也許只要找出好的算法就行了
  * 並且
    如果放棄在每個函數中對新陳代謝的模擬
    讓每個函數的都以全局的鏈表爲自己的數據部分
    那麼就差不多有個模型了
  * 然而
    函數調用的實現方式呢
    如果純粹使用消息傳遞
    那麼參數棧就沒有了
    計算的順序也沒有了
    必須有以維持順序的機制
    線程系統的解釋器和它的 參數棧 和 返回棧
    就作爲一個調度性的協調系統了
    這是可以想像的
    因爲內部解釋器本身利用返回棧來記錄計算位置的方式
    本來就是一種調度
  * 也就是說
    線程碼解釋器本身的地位與其他的函數平等了
    但是
    每個函數都在不停地
    與線程碼解釋器 之間傳遞信息
    這是不合理的
    應該把 線程碼解釋器 的功能內化到每個函數中
    [既然每個函數都被視爲一個有獨立計算能力的機器了]
    每個函數都有用鏈表實現的棧 就行了
    在每個函數體內調用了別的函數的時候
    就是給別的函數傳遞了消息並且等待消息返回
    這樣計算的狀態的編碼就被分散到了各個函數內部
    而不再需要返回棧了 [也沒法實現 call/cc 了]
  * 這種模型能夠適應在 組合子問答集 中
    所發展起來的語義和語法嗎
    要知道
    對計算順序的明指
    在這裏就體現爲
    對返回信息的等待的明指
    而 A (F) (G)
    就是語言的用戶接口[REPL]
    在形成一個消息 A
    然後把這個消息傳遞給函數 F
    返回的消息可以
    1. 返回到 REPL
       然後再順次處理
    2. 在 REPL 把消息 A 傳遞給 F 的時候
       告訴 F 當計算完成之後把結果返回給 G
       並且 G 還必須知道計算完之後
       結果要最終返回給 REPL
       也就是說整個函數
       都必須編碼在這個函數提所傳遞的參數中
       這是不合理的
    3. REPL 在給 F 傳遞參數的同時
       告訴 G 如果接受到 F 傳來的信息
       那麼對這個信息的計算結果應該返回給 REPL
       這樣每個函數每次所計算的參數上
       就都帶有[固定大小的]信息
       比如 A 上帶有 [來自: REPL 目的地:G]
       並且每次作用都必須有不同的標籤 以被識別
  * 這些都是可以想像的
    但是我還是先以單線程爲主來實現我的語言
    我想以後再去考慮多線程的版本也不難
