---
---
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <title>cicada-nymph.org</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style type="text/css">
    <!--
      body {
        color: #f8f8f0;
        background-color: #1b1d1e;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #a6e22e;
      }
      .cicada-nymph-comment {
        /* cicada-nymph-comment-face */
        color: #FF8888;
      }
      .cicada-nymph-end {
        /* cicada-nymph-end-face */
        color: #00ffff;
        font-weight: bold;
      }
      .cicada-nymph-lexicographer {
        /* cicada-nymph-lexicographer-face */
        color: #ae81ff;
        font-weight: bold;
      }
      .cicada-nymph-number {
        /* cicada-nymph-number-face */
        color: #fd971f;
        font-weight: bold;
      }
      .cicada-nymph-sentence-reader {
        /* cicada-nymph-sentence-reader-face */
        color: #ffff00;
        font-weight: bold;
      }
      .cicada-nymph-syntax-key-word {
        /* cicada-nymph-syntax-key-word-face */
        color: #f92672;
        font-weight: bold;
      }
      .cicada-nymph-variable {
        /* cicada-nymph-variable-face */
        color: #fd971f;
      }
      .cicada-nymph-word-to-define {
        /* cicada-nymph-word-to-define-face */
        color: #ef5939;
        font-weight: bold;
      }
      .comment {
        /* font-lock-comment-face */
        color: #FF8888;
      }
      .constant {
        /* font-lock-constant-face */
        color: #ae81ff;
      }
      .default {
        /* default */
        color: #f8f8f0;
        background-color: #1b1d1e;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #a6e22e;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #f92672;
        font-weight: bold;
      }
      .org-block {
        /* org-block */
        color: #b3b3b3;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        color: #FF8888;
      }
      .org-block-end-line {
        /* org-block-end-line */
        color: #FF8888;
      }
      .org-document-info {
        /* org-document-info */
        color: #afeeee;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #b3b3b3;
      }
      .org-document-title {
        /* org-document-title */
        color: #afeeee;
        font-weight: bold;
      }
      .org-done {
        /* org-done */
        color: #98fb98;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #a6e22e;
      }
      .org-level-2 {
        /* org-level-2 */
        color: #fd971f;
      }
      .org-level-3 {
        /* org-level-3 */
        color: #f92672;
        font-weight: bold;
      }
      .org-link {
        /* org-link */
        color: #00ffff;
        text-decoration: underline;
      }
      .org-table {
        /* org-table */
        color: #87cefa;
      }
      .org-todo {
        /* org-todo */
        color: #ffc0cb;
        font-weight: bold;
      }
      .preprocessor {
        /* font-lock-preprocessor-face */
        color: #a6e22e;
      }
      .return-stack-bar-ket {
        /* return-stack-bar-ket-face */
        color: #dc322f;
        font-weight: bold;
      }
      .return-stack-end {
        /* return-stack-end-face */
        color: #00ffff;
        font-weight: bold;
      }
      .return-stack-jo {
        /* return-stack-jo-face */
        color: #ef5939;
        font-weight: bold;
      }
      .return-stack-line {
        /* return-stack-line-face */
        color: #ae81ff;
        font-weight: bold;
      }
      .return-stack-the-jo {
        /* return-stack-the-jo-face */
        color: #fd971f;
        font-weight: bold;
      }
      .string {
        /* font-lock-string-face */
        color: #e6db74;
      }
      .type {
        /* font-lock-type-face */
        color: #66d9ef;
        font-weight: bold;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #fd971f;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
{% include in-org-head.html %}
  </head>
  <body>
    {% include before-pre.html %}
<pre>
<span class="org-document-info-keyword">#+TITLE:</span>  <span class="org-document-title">cicada-nymph
</span><span class="org-document-info-keyword">#+AUTHOR:</span> <span class="org-document-info">&#35613;&#23431;&#24646; / XIE Yuheng
</span><span class="org-document-info-keyword">#+EMAIL:</span>  <span class="org-document-info">xyheme@gmail.com
</span>
<span class="org-level-1">* </span><span class="org-done">todo</span>
<span class="org-level-2">** load-file [windows version]</span>
<span class="org-level-2">** [when needed] nested load-file</span>
   * a stack of buffer would solve this problem
<span class="org-level-2">** [maybe] make instruction a type of jo</span>
   this is needed when doing report of the dictionary
<span class="org-level-2">** 32bit port for linux</span>
<span class="org-level-2">** 32bit port for windows</span>
<span class="org-level-2">** [maybe] re generate instars</span>
<span class="org-level-1">* ===================================</span>
<span class="org-level-1">* </span><span class="org-todo">note</span>
<span class="org-level-2">** jo &amp; jojo</span>
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "&#29664;&#29664;" in Chinese]
<span class="org-level-2">** naming convention</span>
   * a predicate of a type
     which denotes a subtype of that type
     uses that type as postfix
     such as
     "space-char?"
   * a function of a type
     uses that type as prefix
     such as
     "string-reverse"
     "string-equal?"
   * side-effect of structured data is postfixed by "!"
<span class="org-level-2">** convention in assembly code</span>
   * using underline to compose big word from small words
   * using "$" as prefix and postfix separator
   * indentation level = 3
   * naming convention of jo
     <span class="org-table">| convention   | jo type  |</span>
     <span class="org-table">|--------------+----------|</span>
     <span class="org-table">| prefix "V__" | variable |</span>
     <span class="org-table">| prefix "M__" | macro    |</span>
   * but I use
     1. "zero" instead of "V__zero"
     2. "true" instead of "V__true"
<span class="org-level-2">** convention in cicada-nymph code</span>
   * using dash to compose big word from small words
   * using "," as prefix and postfix separator
   * indentation style = free
   * words are separated by space
     except for bar-ket
     every bar-ket is viewed as a word
<span class="org-level-2">** syntax of cicada-nymph</span>
   * syntax &amp;  semantic
     <span class="org-table">| syntax          | semantic                  |</span>
     <span class="org-table">|-----------------+---------------------------|</span>
     <span class="org-table">| borderfix "* *" | variable                  |</span>
     <span class="org-table">| borderfix "+ +" | [maybe use]               |</span>
     <span class="org-table">| bar-ket ( )     | not use                   |</span>
     <span class="org-table">| bar-ket [ ]     | not use                   |</span>
     <span class="org-table">| bar-ket { }     | macro call                |</span>
     <span class="org-table">|                 | (for macros of which      |</span>
     <span class="org-table">|                 | the number of             |</span>
     <span class="org-table">|                 | arguments is not fix)     |</span>
     <span class="org-table">| double-quote    | viewed as special bar-ket |</span>
     <span class="org-table">|                 | (bar is the same as ket)  |</span>
     <span class="org-table">|                 | to support string literal |</span>
     <span class="org-table">| prefix "!"      | exception                 |</span>
     <span class="org-table">| postfix "!"     | some of the side-effect   |</span>
     <span class="org-table">| postfix "?"     | predicate                 |</span>
   * but I use
     1. "true" instead of "<span class="bold">*true*</span>"
     2. "false" instead of "<span class="bold">*false*</span>"
<span class="org-level-2">** unique id</span>
   * if one wish to get a named unique id
     a jo maybe used
     for a jo is an address in memory
     it is unique as a memory address
   * but there is not effort made
     to distinguish address and fixnum
     as different type of things
     thus
     this kind of unique id is not fit
     for some tasks
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* </span><span class="org-todo">note</span><span class="org-level-1"> different from the re-designed cicada-language</span>
   * simplifications are for teaching purpose only
   * first and foremost
     function programming will NOT be supported in this implementation
   * a helper function must be defined before it is used
   * no mixfix-notation
     * function call is "function" instead of "(function)"
     * no such thing like
       1 2 (add) = 1 (add 2) = (add 1 2)
   * no named local argument
     * thus no inited local argument
   * no title-name-table
     * thus in this implementation
       we only use single name space
     * thus in this implementation
       we do NOT have the concept of "context"
       so
       the syntax is not as flexible as it will be in cicada-language
   * no type
     * no type inference
     * no dynamic type tag
     * no static type declaration
   * global linked-list for naming
     * not hash-table
     * by the way
       in classical forth
       the linked-list of jo is called dictionary
   * no dynamic-memory-management
     * no garbage-collector
   * about comment
     * the comment of the argument &amp; return value of function
       is allowed to be written in free style normal comment
<span class="org-level-1">* ===================================</span>
<span class="org-level-1">* prolog</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> conditional preprocessing</span>
   * flower bar-ket can not be nested in fasm's "match"
     so
     1. when defining macro conditionally
        one should use "if eq" &amp; "finish if"
     2. when doing "define" or "equ"
        one should use "match { }"
<span class="org-level-2">** platform configuration</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;;;; before you compile the code
</span>   <span class="comment">;;;; do not forget to choose your platform
</span>   <span class="comment">;;;; in the following code
</span>
   <span class="preprocessor">include</span> <span class="string">"platform-configuration.inc"</span>

   <span class="comment">;; define platform linux or windows
</span>   <span class="comment">;; define machine  64bit or 32bit
</span><span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** misc</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; in fasm, "dup" is a reserved word
</span>   <span class="keyword">dup</span> <span class="preprocessor">equ</span> duplicate

   <span class="comment">;; in fasm, "end" is a reserved word
</span>   <span class="keyword">finish</span> <span class="preprocessor">equ</span> <span class="keyword">end</span>
   <span class="keyword">end</span> <span class="preprocessor">equ</span> exit
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** header [linux64]</span>
   * note that
     the following code is not in a if-block
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {


   <span class="preprocessor">define</span> linux64_sys_6_r8  <span class="variable-name">r8</span>
   <span class="preprocessor">define</span> linux64_sys_5_r9  <span class="variable-name">r9</span>
   <span class="preprocessor">define</span> linux64_sys_4_r10 <span class="variable-name">r10</span>
   <span class="preprocessor">define</span> linux64_sys_3_rdx <span class="variable-name">rdx</span>
   <span class="preprocessor">define</span> linux64_sys_2_rsi <span class="variable-name">rsi</span>
   <span class="preprocessor">define</span> linux64_sys_1_rdi <span class="variable-name">rdi</span>
   <span class="preprocessor">define</span> linux64_sys_n_rax <span class="variable-name">rax</span>

   <span class="preprocessor">define</span> linux64_syscall_read  <span class="constant">0</span>
   <span class="preprocessor">define</span> linux64_syscall_write <span class="constant">1</span>
   <span class="preprocessor">define</span> linux64_syscall_open  <span class="constant">2</span>
   <span class="preprocessor">define</span> linux64_syscall_close <span class="constant">3</span>
   <span class="preprocessor">define</span> linux64_syscall_exit  <span class="constant">60</span>


   <span class="comment">;; about open &amp; read &amp; write
</span>
   open_read         = <span class="constant">0</span>
   open_write        = <span class="constant">1</span>
   open_readAndWrite = <span class="constant">2</span>

   open_creat      = 0100o
   open_rewrite    = 1000o <span class="comment">;; rewrite if file exist
</span>   open_append     = 2000o

   open_excl       = 0200o <span class="comment">;; ensure that THIS call creates the file
</span>   open_noctty     = 0400o
   open_nonblock   = 4000o
   open_nondelay   = open_nonblock
   open_sync       = 10000o
   open_async      = 20000o
   open_direct     = 40000o
       <span class="comment">;; to minimize cache effects of the I/O to and from this file.
</span>
   open_largefile  = 100000o
   open_directory  = 200000o
   open_nofollow   = 400000o <span class="comment">;; If pathname is a symbolic link, then the open fails.
</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** format header [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   <span class="keyword">format</span> elf64 <span class="keyword">executable</span> <span class="constant">3</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** entry [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   <span class="keyword">entry</span> begin_to_interpret_threaded_code
   <span class="keyword">segment</span> <span class="keyword">readable</span> <span class="keyword">executable</span> <span class="keyword">writeable</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** header [windows64]</span>
   * note that
     the following code is not in a if-block
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">define</span> windows64_fun_4_r9  <span class="variable-name">r9</span>
   <span class="preprocessor">define</span> windows64_fun_3_r8  <span class="variable-name">r8</span>
   <span class="preprocessor">define</span> windows64_fun_2_rdx <span class="variable-name">rdx</span>
   <span class="preprocessor">define</span> windows64_fun_1_rcx <span class="variable-name">rcx</span>

   <span class="preprocessor">define</span> STD_INPUT_HANDLE  -<span class="constant">10</span>
   <span class="preprocessor">define</span> STD_OUTPUT_HANDLE -<span class="constant">11</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** format header [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {

   <span class="keyword">format</span> PE64 <span class="keyword">console</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** entry [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {

   <span class="keyword">entry</span> begin_to_interpret_threaded_code
   <span class="keyword">section</span> <span class="default">'.text'</span> code <span class="keyword">writeable</span> <span class="keyword">readable</span> <span class="keyword">executable</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** macro about calling-convention [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="keyword">if</span> platform <span class="keyword">eq</span> windows
   <span class="keyword">if</span> machine <span class="keyword">eq</span> 64bit


   <span class="comment">;; &#36889;&#35023;&#30340; number_of_arguments &#20854;&#23526;&#20195;&#34920;
</span>   <span class="comment">;; &#22312;&#23565;&#40778;&#26855;&#20043;&#24460;
</span>   <span class="comment">;; &#20320;&#36996;&#24819;&#35201;&#23559;&#26855;&#30340;&#25351;&#37341; &#21521;&#19979;&#31227;&#21205;&#22810;&#23569;&#20491;&#21934;&#20301;
</span>   <span class="comment">;; &#26681;&#25818; windows calling convention
</span>   <span class="comment">;; &#36889;&#20491;&#25976;&#23383;&#26368;&#23569;&#26159; 4
</span>
   <span class="preprocessor">macro</span> <span class="function-name">windows_function</span> number_of_arguments {
      <span class="builtin">push</span> <span class="variable-name">rbp</span>
      <span class="builtin">mov</span> <span class="variable-name">rbp</span>, <span class="variable-name">rsp</span>

      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="variable-name">rsp</span>
      <span class="builtin">add</span> <span class="variable-name">rax</span>, <span class="constant">8</span>*number_of_arguments
      <span class="builtin">mov</span> <span class="variable-name">rbx</span>, <span class="constant">1111b</span>
      <span class="builtin">and</span> <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>

      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">16</span>
      <span class="builtin">add</span> <span class="variable-name">rsp</span>, <span class="variable-name">rbx</span>
   }

   <span class="preprocessor">macro</span> <span class="function-name">end_windows_function</span> {
      <span class="builtin">mov</span> <span class="variable-name">rsp</span>, <span class="variable-name">rbp</span>
      <span class="builtin">pop</span> <span class="variable-name">rbp</span>
   }


   <span class="keyword">finish</span> <span class="keyword">if</span>
   <span class="keyword">finish</span> <span class="keyword">if</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* macro in assembly code</span>
<span class="org-level-2">** jo_size [32bit]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =32bit, machine {


   jo_size = <span class="constant">4</span> <span class="comment">;; (byte)
</span>   <span class="type">xx</span> <span class="preprocessor">equ</span> <span class="type">dd</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo_size [64bit]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =64bit, machine {

   jo_size = <span class="constant">8</span> <span class="comment">;; (byte)
</span>   <span class="type">xx</span> <span class="preprocessor">equ</span> <span class="type">dq</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** argument_stack &amp; return_stack</span>
   * when doing "push"
     a stack-pointer moves to lower address
   * note that another style is that
     when doing "push"
     a stack-pointer moves to higher address
   * the stack-pointer
     always stores the address of current-free-address of the stack
   * note that another style is that
     under the stack-pointer
     there always stores the value of the-top-of-the-stack
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; if you want to extend cicada in assembly
</span>   <span class="comment">;; the following registers must NOT be used
</span>
   <span class="comment">;; =================================
</span>   <span class="preprocessor">define</span> pointer$argument_stack   <span class="variable-name">r15</span>
   <span class="preprocessor">define</span> pointer$return_stack     <span class="variable-name">r14</span>
   <span class="comment">;; =================================
</span>
   <span class="preprocessor">macro</span> <span class="function-name">push_argument_stack</span> register {
      <span class="builtin">mov</span> [pointer$argument_stack], register
      <span class="builtin">add</span> pointer$argument_stack, jo_size
      }
   <span class="preprocessor">macro</span> <span class="function-name">pop_argument_stack</span> register {
      <span class="builtin">sub</span> pointer$argument_stack, jo_size
      <span class="builtin">mov</span> register, [pointer$argument_stack]
      }

   <span class="preprocessor">macro</span> <span class="function-name">push_return_stack</span> register {
      <span class="builtin">mov</span> [pointer$return_stack], register
      <span class="builtin">add</span> pointer$return_stack, jo_size
      }
   <span class="preprocessor">macro</span> <span class="function-name">pop_return_stack</span> register {
      <span class="builtin">sub</span> pointer$return_stack, jo_size
      <span class="builtin">mov</span> register, [pointer$return_stack]
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** memory allocation in un_initialized_memory</span>
   * implemented as a memory map
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   current_free_address$un_initialized_memory = address$un_initialized_memory

   <span class="keyword">labeling</span>  <span class="preprocessor">equ</span> = current_free_address$un_initialized_memory
   <span class="type">preserve</span>  <span class="preprocessor">equ</span> current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** next</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">next</span> {
      pop_return_stack <span class="variable-name">rbx</span>
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, jo_size
      push_return_stack <span class="variable-name">rbx</span>
        <span class="builtin">jmp</span> <span class="type">qword</span> [<span class="variable-name">rax</span>]
   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> play with jo &amp; jojo</span>
   1. at the beginning
      * argument-stack
        &lt;&lt; 2 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(square)</span>
            <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span>   2. next
      * argument-stack
        &lt;&lt; 2 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(dup)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-end">(end)</span>          <span class="return-stack-jo">(multiple)</span>
                           <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span>   3. next
      * argument-stack
        &lt;&lt; 2, 2 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>       <span class="return-stack-jo">(dup)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(multiple)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-end">(end)</span>          <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span>   4. next
      * argument-stack &lt;&lt; 4 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>                           <span class="return-stack-jo">(dup)</span>
            <span class="return-stack-jo">(square)</span>       <span class="return-stack-jo">(multiple)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(square)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span>   5. next
      * argument-stack &lt;&lt; 4 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(dup)</span> <span class="return-stack-bar-ket">]</span>
                        <span class="return-stack-jo">(multiple)</span>
                        <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span>   6. next
      * argument-stack
        &lt;&lt; 4, 4 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
            <span class="return-stack-jo">(square)</span>    <span class="return-stack-jo">(dup)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(multiple)</span> <span class="return-stack-bar-ket">]</span>
                        <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span>   7. next
      * argument-stack
        &lt;&lt; 16 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>    <span class="return-stack-jo">(dup)</span>
            <span class="return-stack-jo">(square)</span>    <span class="return-stack-jo">(multiple)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span>
<span class="org-block-end-line">        #+end_src
</span>   8. next
      * argument-stack
        &lt;&lt; 16 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>            <span class="return-stack-jo">(square)</span>
            <span class="return-stack-jo">(square)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span>
<span class="org-block-end-line">        #+end_src
</span>   9. next
      * argument-stack
        &lt;&lt; 16 &gt;&gt;
      * return-stack
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> [  ]
<span class="org-block-end-line">        #+end_src
</span>   10. it is really simple
       ^-^
       is it not ?
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* helper function in assembly code</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** __exit_with_TOS [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   __exit_with_TOS:
      pop_argument_stack linux64_sys_1_rdi
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_exit
      <span class="builtin">syscall</span>

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** __exit_with_zero [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   __exit_with_zero:
      <span class="builtin">xor</span> linux64_sys_1_rdi, linux64_sys_1_rdi
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_exit
      <span class="builtin">syscall</span>

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** __exit_with_six [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   __exit_with_six:
      <span class="builtin">mov</span> linux64_sys_1_rdi, <span class="constant">6</span>
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_exit
      <span class="builtin">syscall</span>

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> windows calling convention for x86-64</span>
   * <span class="org-link"><a href="https://msdn.microsoft.com/en-us/library/ew5tede7%28v=vs.90%29.aspx">microsoft's web</a></span>
   * if you respect the calling convention
     1. your functions will be able to call other functions
        which respect the calling convention
     2. your functions will be call-able by other functions
        which respect the calling convention
   * in our program
     1. we do NOT need to respect the calling convention
        to let our functions be call-able by other function
        which respect the calling convention
     2. we ONLY need to respect the calling convention
        to let our functions be able to call other functions
        which respect the calling convention
   * before a call to function in kernel
     you have to 16-byte aligne the stack
   * pass first 4 arguments by rcx rdx r8 r9
     pass other arguments by stack
   * you have to reserve 4 place for the first 4 arguments
     although you do not need to push them into stack
   * you have to reserve 4 place for the first 4 arguments
     even if the function you are calling
     only uses less then 4 arguments
   * the code I am using
     to handle windows calling convention
     is de-macro-lized and un-optimized
     this is for teaching purpose only
<span class="org-level-2">** __exit_with_TOS [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {

   __exit_with_TOS:

   windows_function <span class="constant">4</span>
      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">8</span>*<span class="constant">4</span>
      pop_argument_stack windows64_fun_1_rcx
      <span class="builtin">call</span> [ExitProcess]
   end_windows_function

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** __exit_with_zero [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {

   __exit_with_zero:

   windows_function <span class="constant">4</span>
      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">8</span>*<span class="constant">4</span>
      <span class="builtin">xor</span> windows64_fun_1_rcx, windows64_fun_1_rcx
      <span class="builtin">call</span> [ExitProcess]
   end_windows_function

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** __exit_with_six [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {

   __exit_with_six:

   windows_function <span class="constant">4</span>
      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">8</span>*<span class="constant">4</span>
      <span class="builtin">mov</span> windows64_fun_1_rcx, <span class="constant">6</span>
      <span class="builtin">call</span> [ExitProcess]
   end_windows_function

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* macro for jo &amp; explainer</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** link</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; initial link to point to 0 (as null)
</span>   link = <span class="constant">0</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** primitive_string_heap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   size$primitive_string_heap = <span class="constant">100</span> * <span class="constant">1024</span> <span class="comment">;; (byte)
</span>
   <span class="function-name">address$primitive_string_heap</span>:
      <span class="keyword">times</span> size$primitive_string_heap <span class="type">db</span> <span class="constant">0</span>

   current_free_address$primitive_string_heap = address$primitive_string_heap
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** make_primitive_string</span>
   * 2 bytes for length of name_string
   * note that
     the following is using local label
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">make_primitive_string</span> string {

   <span class="keyword">virtual</span> <span class="keyword">at</span> <span class="constant">0</span>
   <span class="function-name">.start$string</span>:
      <span class="type">db</span> string
   <span class="function-name">.end$string</span>:
      <span class="type">dw</span> (.end$string - .start$string)
      <span class="keyword">load</span> .length <span class="type">word</span> <span class="keyword">from</span> (.end$string)
   <span class="keyword">finish</span> <span class="keyword">virtual</span>
   <span class="keyword">store</span> <span class="type">word</span> .length <span class="keyword">at</span> (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + <span class="constant">2</span>

   <span class="keyword">repeat</span> .length
      <span class="keyword">virtual</span> <span class="keyword">at</span> <span class="constant">0</span>
         <span class="type">db</span> string
         <span class="keyword">load</span> .char <span class="type">byte</span> <span class="keyword">from</span> (% - <span class="constant">1</span>)
      <span class="keyword">finish</span> <span class="keyword">virtual</span>
      <span class="keyword">store</span> <span class="type">byte</span> .char <span class="keyword">at</span> (current_free_address$primitive_string_heap)
      current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + <span class="constant">1</span>
   <span class="keyword">finish</span> <span class="keyword">repeat</span>

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * note that
     after a "next" "jmp" to a explainer
     the "rax" stores the value of the jo to be explained
     so
     "rax" is used as an inexplicit argument
     of the following functions
   * explain$function is used as jojo-head
     and explains the meaning of the jojo as function
   * a jojo-head identifies one type of jo
<span class="org-level-2">** define_function</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_function</span> string, <span class="builtin">jo</span> {

   define_function__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$function

      <span class="comment">;; here follows a jojo as function-body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** explain$function</span>
   * find a jojo from a function-jo
     and push the jojo to return-stack
   * a jojo can not be of size 0
   * use rax as an argument
     which stores a jo
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$function</span>:
      <span class="builtin">add</span> <span class="variable-name">rax</span>, jo_size
      push_return_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * primitive functions are special
     they explain themself
     and their type is not identified by jojo-head
<span class="org-level-2">** define_primitive_function</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_primitive_function</span> string, <span class="builtin">jo</span> {

   define_primitive_function__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> assembly_code__#<span class="builtin">jo</span>

   assembly_code__#<span class="builtin">jo</span>:

      <span class="comment">;; here follows assembly code
</span>      <span class="comment">;; as primitive function body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
<span class="org-level-2">** define_variable</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_variable</span> string, <span class="builtin">jo</span> {

   define_variable__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$variable

      <span class="comment">;; here follows a value of jo_size
</span>      <span class="comment">;; only one value is allowed
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** explain$variable</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$variable</span>:
      <span class="builtin">add</span> <span class="variable-name">rax</span>, jo_size
      <span class="builtin">mov</span> <span class="variable-name">rbx</span>, [<span class="variable-name">rax</span>]
      push_argument_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-level-2"><span class="bold">*primitive-string-heap*</span></span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*primitive-string-heap*"</span>, V__primitive_string_heap
     <span class="type">xx</span> address$primitive_string_heap

   define_variable <span class="string">"*size,primitive-string-heap*"</span>, V__size__primitive_string_heap
     <span class="type">xx</span> size$primitive_string_heap

   <span class="comment">;; *current-free-address,primitive-string-heap*
</span>   <span class="comment">;; is at epilog
</span><span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* macro for make-jojo</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * the same as function
     we need to redefine it
     for the value of explainer
     is used to decide the type of the jo
<span class="org-level-2">** define_macro</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_macro</span> string, <span class="builtin">jo</span> {

   define_macro__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$macro

      <span class="comment">;; here follows a jojo as function-body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** explain$macro</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$macro</span>:
      <span class="builtin">add</span> <span class="variable-name">rax</span>, jo_size
      push_return_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * explain$exception will
     1. search the return-stack for that exception
     2. special side-effect on return-stack
        to do exception handling
<span class="org-level-2">** define_exception</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">macro</span> <span class="function-name">define_exception</span> string, <span class="builtin">jo</span> {

   define_exception__#<span class="builtin">jo</span>:

   name__#<span class="builtin">jo</span>:
      <span class="type">xx</span> current_free_address$primitive_string_heap

      make_primitive_string string

   link__#<span class="builtin">jo</span>:
      <span class="type">xx</span> link
      link = link__#<span class="builtin">jo</span>

   <span class="builtin">jo</span>:
      <span class="type">xx</span> explain$exception

      <span class="comment">;; here follows a jojo as function-body
</span>
      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> return-stack in action</span>
   1. when "explain$exception" is called
      jojo by jojo
      it searchs the jo stored in "rax" in the return-stack
      of course
      only jojo with "exception_head" as head needs to be searched
   2. for example
      we have
<span class="org-block-begin-line">      #+begin_src fasm
</span>      define_exception <span class="string">"!exception-1"</span>, !exception_1
         <span class="type">xx</span> fun1
         <span class="type">xx</span> fun2
         <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">      #+end_src
</span>   3. return-stack
<span class="org-block-begin-line">      #+begin_src return-stack
</span>                                               <span class="return-stack-jo">(prepare_for)</span>
                                                 <span class="return-stack-jo">(exception_head)</span>
                                                 <span class="return-stack-jo">(!exception_1)</span>
                                                 <span class="return-stack-jo">(!exception_2)</span>
                                                 <span class="return-stack-jo">(end_of_prepare)</span>
                      <span class="return-stack-jo">(prepare_for)</span>            <span class="return-stack-jo">(function_1)</span>
      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">pointer</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(exception_head)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(function_2)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(!exception_1)</span> <span class="return-stack-bar-ket">]</span>
                        <span class="return-stack-jo">(!exception_1)</span>         <span class="return-stack-end">(end)</span>              <span class="return-stack-end">(end)</span>
                        <span class="return-stack-jo">(!exception_2)</span>
                        <span class="return-stack-jo">(end_of_prepare)</span>
                      <span class="return-stack-jo">(function_1)</span>
                      <span class="return-stack-jo">(function_2)</span>
                      <span class="return-stack-end">(end)</span>

      the pointer above is into argument-stack
<span class="org-block-end-line">      #+end_src
</span>   4. next
      * pointer$argument_stack
        should be set to the pointer above
      * and
        to call "next" again
        the return-stack should be change to
<span class="org-block-begin-line">        #+begin_src return-stack
</span>        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(fun1)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(fun2)</span>
            <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> the plan</span>
   * so
     we need a two-level loop
   * note that
     although
     we have to use assembly code
     to write primitive functions
     but
     we still can use argument-stack
     to pass arguments
<span class="org-level-2">** explain$exception</span>
   * no error handling for now
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">explain$exception</span>:
      <span class="builtin">mov</span> <span class="variable-name">rsi</span>, <span class="variable-name">rax</span>

   <span class="function-name">.next_jojo</span>:
      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">cmp</span> <span class="variable-name">rax</span>, exception_head
      <span class="builtin">je</span> .next_jo
      <span class="builtin">cmp</span> pointer$return_stack, address$return_stack
      <span class="builtin">je</span> .not_found
      <span class="builtin">jmp</span> .next_jojo


   <span class="function-name">.next_jo</span>:
      <span class="comment">;; expecting
</span>      <span class="comment">;;   rbx jojo
</span>      <span class="comment">;;   rsi jo (to cmp)
</span>      <span class="builtin">add</span> <span class="variable-name">rbx</span>, jo_size
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">cmp</span> <span class="variable-name">rax</span>, <span class="variable-name">rsi</span>
      <span class="builtin">je</span> .found
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jz</span> .next_jojo
      <span class="builtin">jmp</span> .next_jo


   <span class="function-name">.found</span>:
      <span class="comment">;; expecting
</span>      <span class="comment">;;   pointer$return_stack
</span>      <span class="comment">;;   rsi jo
</span>      pop_return_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span> pointer$argument_stack, <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="variable-name">rsi</span>, jo_size
      push_return_stack <span class="variable-name">rsi</span>
      next

   <span class="function-name">.not_found</span>:
      <span class="builtin">call</span> __exit_with_six
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* execute-jo &amp; structure of jo</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** execute-jo</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"execute-jo"</span>, execute_jo
      <span class="comment">;; &lt;&lt; jo -- UNKNOWN &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">jmp</span> <span class="type">qword</span> [<span class="variable-name">rax</span>]
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-level-2"><span class="bold">*jo-size*</span></span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*jo-size*"</span>, V__jo_size
      <span class="type">xx</span> <span class="constant">8</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo-&gt;name</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;name"</span>, jo_to_name
      <span class="comment">;; &lt;&lt; jo -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, jo_size, subtraction
      <span class="type">xx</span> <span class="keyword">literal</span>, jo_size, subtraction
      <span class="type">xx</span> fetch
      <span class="type">xx</span> <span class="keyword">dup</span>
      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="constant">2</span>, addition, swap
      <span class="type">xx</span> fetch_two_bytes
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo-&gt;link</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;link"</span>, jo_to_link
      <span class="comment">;; &lt;&lt; jo -- link &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, jo_size
      <span class="type">xx</span> subtraction
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** last-jo,dictionary?</span>
   * first jo in assembly code
     is the last jo in dictionary
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"last-jo,dictionary?"</span>, last_jo__dictionary?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span> fetch
      <span class="type">xx</span> zero?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo-&gt;pre-jo</span>
   * treat last-jo,dictionary specially
     i.e. return zero on that case
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;pre-jo"</span>, jo_to_pre_jo
      <span class="comment">;; &lt;&lt; jo -- pre-jo &gt;&gt;
</span>      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span> fetch
      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">literal</span>, jo_size
      <span class="type">xx</span> addition
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** jo-&gt;type</span>
   * the type of primitive function jo
     is encoded by 0
   * other types of jo
     are encoded by their explainers
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"jo-&gt;type"</span>, jo_to_type
      <span class="comment">;; &lt;&lt; jo -- type &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>

      <span class="type">xx</span> <span class="keyword">dup</span>, fetch
      <span class="type">xx</span> swap, subtraction, <span class="keyword">literal</span>, <span class="constant">8</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, zero
      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="type">xx</span> fetch
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* type of jo</span>
<span class="org-level-2">** primitive-function-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"primitive-function-jo?"</span>, primitive_function_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> zero?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** function-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"function-jo?"</span>, function_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> <span class="keyword">literal</span>, explain$function
      <span class="type">xx</span> equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** macro-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"macro-jo?"</span>, macro_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> <span class="keyword">literal</span>, explain$macro
      <span class="type">xx</span> equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** exception-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"exception-jo?"</span>, exception_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> <span class="keyword">literal</span>, explain$exception
      <span class="type">xx</span> equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** variable-jo?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"variable-jo?"</span>, variable_jo?
      <span class="comment">;; &lt;&lt; jo -- bool &gt;&gt;
</span>      <span class="type">xx</span> jo_to_type
      <span class="type">xx</span> <span class="keyword">literal</span>, explain$variable
      <span class="type">xx</span> equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* end &amp; taca</span>
<span class="org-level-2">** end</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"end"</span>, <span class="keyword">end</span>
      pop_return_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** taca</span>
   * tail-call
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"&lt;&gt;"</span>, <span class="keyword">taca</span>
      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">jmp</span> <span class="type">qword</span> [<span class="variable-name">rax</span>]
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> explicit tail call in action</span>
   1. the tail position of a function body must be recognized
      explicit tail call is used to achieve this
   2. thus
      tail-recursive-call can be use to do loop
      without pushing too many address into return-stack
   3. for example if we have a function
      which is called "example"
<span class="org-block-begin-line">      #+begin_src fasm
</span>      define_function <span class="string">"example"</span>, example
         <span class="type">xx</span> fun1
         <span class="type">xx</span> fun2
         <span class="type">xx</span> <span class="keyword">taca</span>, example
<span class="org-block-end-line">      #+end_src
</span>   4. and we have the following jojo in return-stack
<span class="org-block-begin-line">      #+begin_src return-stack
</span>      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(example)</span> <span class="return-stack-bar-ket">]</span>
          <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">      #+end_src
</span>   5. next
<span class="org-block-begin-line">      #+begin_src return-stack
</span>          <span class="return-stack-jo">(example)</span>
      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(fun1)</span> <span class="return-stack-bar-ket">]</span>
                      <span class="return-stack-jo">(fun2)</span>
                      <span class="return-stack-end">(taca)</span>
                      <span class="return-stack-jo">(example)</span>
<span class="org-block-end-line">      #+end_src
</span>   6. next
<span class="org-block-begin-line">      #+begin_src return-stack
</span>          <span class="return-stack-jo">(example)</span>   <span class="return-stack-jo">(fun1)</span>
      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(fun2)</span> <span class="return-stack-bar-ket">]</span>
                      <span class="return-stack-end">(taca)</span>
                      <span class="return-stack-jo">(example)</span>
<span class="org-block-end-line">      #+end_src
</span>   7. next
<span class="org-block-begin-line">      #+begin_src return-stack
</span>                      <span class="return-stack-jo">(fun1)</span>
          <span class="return-stack-jo">(example)</span>   <span class="return-stack-jo">(fun2)</span>
      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(taca)</span> <span class="return-stack-bar-ket">]</span>
                      <span class="return-stack-jo">(example)</span>
<span class="org-block-end-line">      #+end_src
</span>   8. next
      by the definition of taca
<span class="org-block-begin-line">      #+begin_src return-stack
</span>          <span class="return-stack-jo">(example)</span>
      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-end">(end)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(fun1)</span> <span class="return-stack-bar-ket">]</span>
                      <span class="return-stack-jo">(fun2)</span>
                      <span class="return-stack-end">(taca)</span>
                      <span class="return-stack-jo">(example)</span>
<span class="org-block-end-line">      #+end_src
</span>   9. you can see return-stack of (8.)
      is the same as (5.)
      it is clear how the example function
      is actually a loop now
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* </span><span class="org-level-1"><span class="bold">*the story begin*</span></span>
<span class="org-level-2">** begin_to_interpret_threaded_code [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   <span class="function-name">begin_to_interpret_threaded_code</span>:

      <span class="builtin">cld</span> <span class="comment">;; set DF = 0, then rsi and rdi are incremented
</span>
      <span class="builtin">mov</span> pointer$argument_stack,  address$argument_stack
      <span class="builtin">mov</span> pointer$return_stack,    address$return_stack

      <span class="builtin">mov</span> <span class="variable-name">rax</span>, first_jojo
      push_return_stack <span class="variable-name">rax</span>
      next

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** begin_to_interpret_threaded_code [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {

   <span class="comment">;;;; for windows
</span>   _output_handle:
      <span class="type">dq</span> <span class="constant">0</span>
   _input_handle:
      <span class="type">dq</span> <span class="constant">0</span>
   <span class="comment">;;;;
</span>
   <span class="function-name">begin_to_interpret_threaded_code</span>:

      <span class="builtin">cld</span> <span class="comment">;; set DF = 0, then rsi and rdi are incremented
</span>
   windows_function <span class="constant">4</span>
      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">8</span>*<span class="constant">4</span>
      <span class="builtin">mov</span> windows64_fun_1_rcx, STD_INPUT_HANDLE
      <span class="builtin">call</span> [GetStdHandle]
      <span class="builtin">mov</span> [_input_handle], <span class="variable-name">rax</span>
   end_windows_function

   windows_function <span class="constant">4</span>
      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">8</span>*<span class="constant">4</span>
      <span class="builtin">mov</span> windows64_fun_1_rcx, STD_OUTPUT_HANDLE
      <span class="builtin">call</span> [GetStdHandle]
      <span class="builtin">mov</span> [_output_handle], <span class="variable-name">rax</span>
   end_windows_function

      <span class="builtin">mov</span> pointer$argument_stack,  address$argument_stack
      <span class="builtin">mov</span> pointer$return_stack,    address$return_stack

      <span class="builtin">mov</span> <span class="variable-name">rax</span>, first_jojo
      push_return_stack <span class="variable-name">rax</span>
      next

   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** first_jojo</span>
   * you can use the following "xx little_test"
     to do some little tests
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">first_jojo</span>:
      <span class="type">xx</span> welcome
      <span class="comment">;; xx little_test
</span>      <span class="type">xx</span> load_init_file
      <span class="type">xx</span> basic_REPL
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** welcome</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"welcome"</span>, welcome
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$welcome_to_cicada_nymph
      <span class="type">xx</span> <span class="keyword">literal</span>, length$welcome_to_cicada_nymph
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>

   <span class="function-name">string$welcome_to_cicada_nymph</span>:
      <span class="type">db</span> <span class="string">"* welcome to cicada-nymph ^-^"</span>
      <span class="type">db</span> <span class="constant">10</span>
   <span class="function-name">.end</span>:
   length$welcome_to_cicada_nymph = (.end - string$welcome_to_cicada_nymph)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** exit_with_TOS a.k.a. bye</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"bye"</span>, exit_with_TOS
      <span class="builtin">call</span> __exit_with_TOS
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** little_test</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">""</span>, V__little_test_number
      <span class="type">xx</span> <span class="constant">3</span>


   define_function <span class="string">"little_test"</span>, little_test

      <span class="comment">;;;; variable
</span>      <span class="comment">;; xx V__little_test_number
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; 3
</span>
      <span class="comment">;;;; literal
</span>      <span class="comment">;; xx literal, 4
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; 4
</span>
      <span class="comment">;;;; address
</span>      <span class="comment">;; xx address, V__little_test_number, fetch, add2
</span>      <span class="comment">;; xx address, V__little_test_number, save
</span>      <span class="comment">;; xx V__little_test_number
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; 5
</span>
      <span class="comment">;;;; write_byte
</span>      <span class="comment">;; xx literal, 64, write_byte
</span>      <span class="comment">;; xx literal, 10, write_byte
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; @
</span>
      <span class="comment">;;;; read_byte
</span>      <span class="comment">;; xx read_byte, write_byte
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;;
</span>
      <span class="comment">;;;; branch
</span>      <span class="comment">;; xx read_byte, write_byte
</span>      <span class="comment">;; xx branch, -3
</span>      <span class="comment">;;;; read a string that ended by &lt;return&gt;
</span>      <span class="comment">;;;; write the readed string
</span>      <span class="comment">;;;; or we can say
</span>      <span class="comment">;;;; read line and write line
</span>      <span class="comment">;;;; or we can say
</span>      <span class="comment">;;;; echo line
</span>
      <span class="comment">;;;; false?branch
</span>      <span class="comment">;; xx V__false, false?branch, 9
</span>      <span class="comment">;; xx   literal, 64, write_byte
</span>      <span class="comment">;; xx   literal, 10, write_byte
</span>      <span class="comment">;; xx   zero
</span>      <span class="comment">;; xx   exit_with_TOS
</span>      <span class="comment">;; xx V__true, false?branch, 9
</span>      <span class="comment">;; xx   literal, 65, write_byte
</span>      <span class="comment">;; xx   literal, 10, write_byte
</span>      <span class="comment">;; xx   zero
</span>      <span class="comment">;; xx   exit_with_TOS
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; A
</span>
      <span class="comment">;;;; read_word &amp; write_string
</span>      <span class="comment">;; xx read_word, write_string
</span>      <span class="comment">;; xx literal, 10, write_byte
</span>      <span class="comment">;; xx read_word_for_REPL, write_string
</span>      <span class="comment">;; xx literal, 10, write_byte
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; read line
</span>      <span class="comment">;;;; write first two words of the line
</span>
      <span class="comment">;;;; string-&gt;integer
</span>      <span class="comment">;; xx read_word, string_to_integer
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; type 123
</span>      <span class="comment">;;;; exit code 123
</span>
      <span class="comment">;;;; use jo_to_name to test the macro make_primitive_string
</span>      <span class="comment">;; xx literal, jo_to_name, jo_to_name, write_string
</span>      <span class="comment">;; xx zero
</span>      <span class="comment">;; xx exit_with_TOS
</span>      <span class="comment">;;;; print "jo-&gt;name"
</span>
      <span class="comment">;;;; basic-REPL (without the ability to define function)
</span>      <span class="comment">;;;; after this test
</span>      <span class="comment">;;;; we will use basic-REPL to do further tests
</span>      <span class="type">xx</span> basic_REPL
      <span class="comment">;;;; 1 2 add .
</span><span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* argument_stack</span>
<span class="org-level-2">** memory allocation</span>
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>      <span class="type">preserve</span> <span class="constant">64</span> * jo_size
   address$argument_stack <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span> * <span class="constant">1024</span> * jo_size
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** drop</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"drop"</span>, drop
      <span class="comment">;; &lt;&lt; a -- &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"drop2"</span>, drop2
      <span class="comment">;; &lt;&lt; a b -- &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      pop_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** dup</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"dup"</span>, <span class="keyword">dup</span>
      <span class="comment">;; &lt;&lt; a -- a a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">1</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"dup2"</span>, dup2
      <span class="comment">;; &lt;&lt; a b -- a b a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rbx</span>, [pointer$argument_stack - (<span class="constant">1</span> * jo_size)]
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">2</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** over</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"over"</span>, over
      <span class="comment">;; &lt;&lt; a b -- a b | a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">2</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"x|over|xx"</span>, xoverxx
      <span class="comment">;; &lt;&lt; a | b c -- a | b c | a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">3</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|over|x"</span>, xxoverx
      <span class="comment">;; &lt;&lt; a b | c -- a b | c | a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">3</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">3</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|over|xx"</span>, xxoverxx
      <span class="comment">;; &lt;&lt; a b | c d -- a b | c d | a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">4</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">4</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"x|over|xxx"</span>, xoverxxx
      <span class="comment">;; &lt;&lt; a | b c d -- a | b c d | a &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">4</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|over|xxxx"</span>, xxoverxxxx
      <span class="comment">;; &lt;&lt; a b | c d e f -- a b | c d e f | a b &gt;&gt;
</span>      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">6</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">mov</span>  <span class="variable-name">rax</span>, [pointer$argument_stack - (<span class="constant">6</span> * jo_size)]
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** tuck</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"tuck"</span>, tuck
      <span class="comment">;; &lt;&lt; a b -- b | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"x|tuck|xx"</span>, xtuckxx
      <span class="comment">;; &lt;&lt; a | b c -- b c | a | b c &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      next

   define_primitive_function <span class="string">"xx|tuck|x"</span>, xxtuckx
      <span class="comment">;; &lt;&lt; a b | c -- c | a b | c &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      next

   define_primitive_function <span class="string">"xx|tuck|xx"</span>, xxtuckxx
      <span class="comment">;; &lt;&lt; a b | c d -- c d | a b | c d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next

   define_primitive_function <span class="string">"xxx|tuck|x"</span>, xxxtuckx
      <span class="comment">;; &lt;&lt; a b c | d -- d | a b c | d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** swap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"swap"</span>, swap
      <span class="comment">;; &lt;&lt; a b -- b a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"x|swap|xx"</span>, xswapxx
      <span class="comment">;; &lt;&lt; a | b c -- b c | a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xx|swap|x"</span>, xxswapx
      <span class="comment">;; &lt;&lt; a b | c -- c | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"x|swap|xxx"</span>, xswapxxx
      <span class="comment">;; &lt;&lt; a | b c d -- b c d | a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xxx|swap|x"</span>, xxxswapx
      <span class="comment">;; &lt;&lt; a b c | d -- d | a b c &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      next

   define_primitive_function <span class="string">"xx|swap|xx"</span>, xxswapxx
      <span class="comment">;; &lt;&lt; a b | c d -- c d | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next


   define_primitive_function <span class="string">"x|swap|xxxx"</span>, xswapxxxx
      <span class="comment">;; &lt;&lt; a | b c d e -- b c d e | a &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"xxxx|swap|x"</span>, xxxxswapx
      <span class="comment">;; &lt;&lt; a b c d | e --  e | a b c d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next


   define_primitive_function <span class="string">"xx|swap|xxxx"</span>, xxswapxxxx
      <span class="comment">;; &lt;&lt; a b | c d e f -- c d e f | a b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"xxxx|swap|xx"</span>, xxxxswapxx
      <span class="comment">;; &lt;&lt; a b c d | e f --  e f | a b c d &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      pop_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      pop_argument_stack <span class="variable-name">rdx</span>
      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">r8</span> <span class="comment">;; e
</span>      push_argument_stack <span class="variable-name">r9</span> <span class="comment">;; f
</span>      push_argument_stack <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rbx</span>
      push_argument_stack <span class="variable-name">rcx</span>
      push_argument_stack <span class="variable-name">rdx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* return_stack</span>
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>      <span class="type">preserve</span> <span class="constant">64</span> * jo_size
   address$return_stack <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span> * <span class="constant">1024</span> * jo_size
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* instruction</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> side-effect</span>
   * an instruction
     is a special primitive function
     which does special side-effect on return-stack
   * note that
     side-effect on return-stack
     should all be done in primitive functions
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> naming</span>
   * the naming convention in assembly code
     of instruction
     is the same as it of jo
   * the name of an instruction
     might not be exported to cicada-language as a function
     but as a variable
   * the name of a special primitive function in assembly code
     maybe reused as a macro word in cicada-language
     but the name of the macro in assembly code
     is prefixed by "M__"
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** literal</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*literal*"</span>, V__literal
      <span class="type">xx</span> <span class="keyword">literal</span>

   define_primitive_function <span class="string">""</span>, <span class="keyword">literal</span>
      <span class="comment">;; &lt;&lt; -- fixnum &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rbx</span>
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
        push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, jo_size
      push_return_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** address</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*address*"</span>, V__address
      <span class="type">xx</span> <span class="keyword">address</span>

   define_primitive_function <span class="string">""</span>, <span class="keyword">address</span>
      <span class="comment">;; &lt;&lt; -- address &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rbx</span>
        <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
        <span class="builtin">add</span> <span class="variable-name">rax</span>, jo_size
        push_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, jo_size
      push_return_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** branch</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*branch*"</span>, V__branch
      <span class="type">xx</span> <span class="keyword">branch</span>

   define_primitive_function <span class="string">""</span>, <span class="keyword">branch</span>
      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
      <span class="builtin">imul</span> <span class="variable-name">rax</span>, jo_size
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      push_return_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** false?branch</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*false?branch*"</span>, V__false?branch
      <span class="type">xx</span> <span class="keyword">false?branch</span>

   define_primitive_function <span class="string">""</span>, <span class="keyword">false?branch</span>
      <span class="comment">;; &lt;&lt; true of false -- &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">test</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">jnz</span> help__false?branch__not_to_branch

      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
      <span class="builtin">imul</span> <span class="variable-name">rax</span>, jo_size
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      push_return_stack <span class="variable-name">rbx</span>
      next

   <span class="function-name">help__false?branch__not_to_branch</span>:
      pop_return_stack <span class="variable-name">rbx</span>
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, jo_size
      push_return_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> return-stack in action</span>
   1. proper exception handling
      is implemented by doing side-effect on return-stack
   2. when executing the following code block
<span class="org-block-begin-line">      #+begin_src fasm
</span>      <span class="type">xx</span> prepare_for
      <span class="type">xx</span> exception_head
      <span class="type">xx</span>   !exception_1
      <span class="type">xx</span>   !exception_2
      <span class="type">xx</span>   end_of_prepare
      <span class="type">xx</span> function_1
      <span class="type">xx</span> function_2
      <span class="type">xx</span> &gt;&lt;&gt;&lt;&gt;&lt; <span class="keyword">end</span>
<span class="org-block-end-line">      #+end_src
</span>   3. return-stack
<span class="org-block-begin-line">      #+begin_src return-stack
</span>      <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(prepare_for)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(exception_head)</span>
            <span class="return-stack-jo">(!exception_1)</span>
            <span class="return-stack-jo">(!exception_2)</span>
            <span class="return-stack-jo">(end_of_prepare)</span>
          <span class="return-stack-jo">(function_1)</span>
          <span class="return-stack-jo">(function_2)</span>
          <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">      #+end_src
</span>   4. next
      * this is how the return-stack looks
        right before exception_head is executed
<span class="org-block-begin-line">        #+begin_src return-stack
</span>          <span class="return-stack-jo">(prepare_for)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(exception_head)</span> <span class="return-stack-bar-ket">]</span>
            <span class="return-stack-jo">(!exception_1)</span>
            <span class="return-stack-jo">(!exception_2)</span>
            <span class="return-stack-jo">(end_of_prepare)</span>
          <span class="return-stack-jo">(function_1)</span>
          <span class="return-stack-jo">(function_2)</span>
          <span class="return-stack-end">(end)</span>
<span class="org-block-end-line">        #+end_src
</span>      * after exception_head is executed
<span class="org-block-begin-line">        #+begin_src return-stack
</span>                                                 <span class="return-stack-jo">(prepare_for)</span>
                                                   <span class="return-stack-jo">(exception_head)</span>
                                                   <span class="return-stack-jo">(!exception_1)</span>
                                                   <span class="return-stack-jo">(!exception_2)</span>
                        <span class="return-stack-jo">(prepare_for)</span>              <span class="return-stack-jo">(end_of_prepare)</span>
        <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">pointer</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(exception_head)</span> <span class="return-stack-bar-ket">]</span> <span class="return-stack-line">-</span> <span class="return-stack-bar-ket">[</span> <span class="return-stack-the-jo">(function_1)</span> <span class="return-stack-bar-ket">]</span>
                          <span class="return-stack-jo">(!exception_1)</span>         <span class="return-stack-jo">(function_2)</span>
                          <span class="return-stack-jo">(!exception_2)</span>         <span class="return-stack-end">(end)</span>
                          <span class="return-stack-jo">(end_of_prepare)</span>
                        <span class="return-stack-jo">(function_1)</span>
                        <span class="return-stack-jo">(function_2)</span>
                        <span class="return-stack-end">(end)</span>

        the pointer above is into argument-stack
<span class="org-block-end-line">        #+end_src
</span><span class="org-level-2">** prepare_for</span>
   * prepare for a list of exceptions
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">""</span>, prepare_for
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rbx</span>
      push_return_stack pointer$argument_stack
      push_return_stack <span class="variable-name">rbx</span>
   <span class="function-name">.next</span>:
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, jo_size
      <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
      <span class="builtin">cmp</span> <span class="variable-name">rax</span>, end_of_prepare
      <span class="builtin">je</span> .then
      <span class="builtin">jmp</span> .next
   <span class="function-name">.then</span>:
      <span class="builtin">add</span> <span class="variable-name">rbx</span>, jo_size
      push_return_stack <span class="variable-name">rbx</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** end_of_prepare</span>
   * used as an unique id
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*end-of-prepare*"</span>, V__end_of_prepare

   <span class="function-name">end_of_prepare</span>:
      <span class="type">xx</span> <span class="constant">0</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** exception_head</span>
   * this jo is served as a label in return-stack
     when explained
     it pops the jojo itself in
     and
     it pops the argument-stack pointer after it
   * and "explain$exception" will search for them
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">""</span>, exception_head
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      pop_return_stack <span class="variable-name">rax</span>
      pop_return_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* bool</span>
<span class="org-level-2">** false &amp; true</span>
   * they are defined as function
     and viewed as constant
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"false"</span>, false
      <span class="comment">;; &lt;&lt; -- false &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"true"</span>, true
      <span class="comment">;; &lt;&lt; -- true &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">inc</span> <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** false? &amp; true?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"false?"</span>, false?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> false, equal?
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"true?"</span>, true?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> true, equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** bitwise operations</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"bitwise-and"</span>, bitwise_and
      <span class="comment">;; &lt;&lt; a, b -- a and b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      <span class="builtin">and</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"bitwise-or"</span>, bitwise_or
      <span class="comment">;; &lt;&lt; a, b -- a or b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      <span class="builtin">or</span>  [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"bitwise-xor"</span>, bitwise_xor
      <span class="comment">;; &lt;&lt; a, b -- a xor b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      <span class="builtin">xor</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"bitwise-invert"</span>, bitwise_invert
      <span class="comment">;; &lt;&lt; a -- invert a &gt;&gt;
</span>      <span class="builtin">not</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)]
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* fixnum</span>
<span class="org-level-2">** zero &amp; one</span>
   * they are defined as function
     and viewed as constant
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"zero"</span>, zero
      <span class="comment">;; &lt;&lt; -- 0 &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"one"</span>, one
      <span class="comment">;; &lt;&lt; -- 1 &gt;&gt;
</span>      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">inc</span> <span class="variable-name">rax</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** zero? &amp; one?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"zero?"</span>, zero?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> zero, equal?
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"one?"</span>, one?
      <span class="comment">;; &lt;&lt; bool -- bool &gt;&gt;
</span>      <span class="type">xx</span> one, equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** add &amp; sub &amp; mul &amp; div &amp; mod &amp; negate &amp; power</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"add1"</span>, add1
      <span class="comment">;; &lt;&lt; n -- n+1 &gt;&gt;
</span>      <span class="builtin">inc</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)]
      next

   define_primitive_function <span class="string">"add2"</span>, add2
      <span class="comment">;; &lt;&lt; n -- n+2 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">2</span>
      next

   define_primitive_function <span class="string">"add3"</span>, add3
      <span class="comment">;; &lt;&lt; n -- n+3 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">3</span>
      next

   define_primitive_function <span class="string">"add4"</span>, add4
      <span class="comment">;; &lt;&lt; n -- n+4 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">4</span>
      next

   define_primitive_function <span class="string">"add8"</span>, add8
      <span class="comment">;; &lt;&lt; n -- n+8 &gt;&gt;
</span>      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">8</span>
      next


   define_primitive_function <span class="string">"sub1"</span>, sub1
      <span class="comment">;; &lt;&lt; n -- n-1 &gt;&gt;
</span>      <span class="builtin">dec</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)]
      next

   define_primitive_function <span class="string">"sub2"</span>, sub2
      <span class="comment">;; &lt;&lt; n -- n-2 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">2</span>
      next

   define_primitive_function <span class="string">"sub3"</span>, sub3
      <span class="comment">;; &lt;&lt; n -- n-3 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">3</span>
      next

   define_primitive_function <span class="string">"sub4"</span>, sub4
      <span class="comment">;; &lt;&lt; n -- n-4 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">4</span>
      next

   define_primitive_function <span class="string">"sub8"</span>, sub8
      <span class="comment">;; &lt;&lt; n -- n-8 &gt;&gt;
</span>      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="constant">8</span>
      next


   define_primitive_function <span class="string">"add"</span>, addition
      <span class="comment">;; &lt;&lt; a b -- a+b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">add</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"sub"</span>, subtraction
      <span class="comment">;; &lt;&lt; a b -- a-b &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">sub</span> <span class="type">qword</span> [pointer$argument_stack - (<span class="constant">1</span> * jo_size)], <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"mul"</span>, multiple
      <span class="comment">;; &lt;&lt; a b -- a*b &gt;&gt;
</span>      pop_argument_stack  <span class="variable-name">rbx</span> <span class="comment">;; 2ed arg
</span>      pop_argument_stack  <span class="variable-name">rax</span> <span class="comment">;; 1st arg
</span>      <span class="builtin">imul</span> <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      <span class="comment">;; imul will ignore overflow
</span>      <span class="comment">;; when there are two registers as arg
</span>      <span class="comment">;; imul will save the result into the first register
</span>      push_argument_stack <span class="variable-name">rbx</span>
      next

   define_primitive_function <span class="string">"moddiv"</span>, moddiv
      <span class="comment">;; &lt;&lt; a, b -- a mod b, quotient &gt;&gt;
</span>      <span class="comment">;; &lt;&lt; dividend, divisor -- remainder, quotient &gt;&gt;
</span>      <span class="comment">;; the arg of idiv is divisor
</span>      <span class="comment">;; the lower half of dividend is taken from rax
</span>      <span class="comment">;; the upper half of dividend is taken from rdx
</span>      <span class="builtin">xor</span>  <span class="variable-name">rdx</span>, <span class="variable-name">rdx</span>   <span class="comment">;; high-part of dividend is not used
</span>      pop_argument_stack  <span class="variable-name">rbx</span> <span class="comment">;; 2ed arg
</span>      pop_argument_stack  <span class="variable-name">rax</span> <span class="comment">;; 1st arg
</span>      <span class="builtin">idiv</span> <span class="variable-name">rbx</span>
      <span class="comment">;; the remainder is stored in rdx
</span>      <span class="comment">;; the quotient  is stored in rax
</span>      push_argument_stack <span class="variable-name">rdx</span> <span class="comment">;; remainder
</span>      push_argument_stack <span class="variable-name">rax</span> <span class="comment">;; quotient
</span>      next


   define_function <span class="string">"divmod"</span>, divmod
      <span class="comment">;; &lt;&lt; a, b -- quotient, a mod b &gt;&gt;
</span>      <span class="type">xx</span> moddiv, swap
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"div"</span>, division
      <span class="comment">;; &lt;&lt; a, b -- quotient &gt;&gt;
</span>      <span class="type">xx</span> divmod, drop
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"mod"</span>, modulo
      <span class="comment">;; &lt;&lt; a, b -- a mod b &gt;&gt;
</span>      <span class="type">xx</span> moddiv, drop
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"negate"</span>, negate
      <span class="comment">;; &lt;&lt; n --  -n &gt;&gt;
</span>      <span class="type">xx</span> zero
      <span class="type">xx</span> swap, subtraction
      <span class="type">xx</span> <span class="keyword">end</span>


   define_function <span class="string">"power"</span>, power
      <span class="comment">;; n must be nature number for now
</span>      <span class="comment">;; &lt;&lt; a, n -- a^n &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">1</span>, swap <span class="comment">;; leave product
</span>      <span class="type">xx</span> help__power
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"help,power"</span>, help__power
      <span class="comment">;; &lt;&lt; a, product, n -- a^n &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">5</span>
      <span class="type">xx</span>   drop, swap, drop
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> sub1
      <span class="type">xx</span> swap
      <span class="type">xx</span>   xoverxx, multiple
      <span class="type">xx</span> swap
      <span class="type">xx</span> <span class="keyword">taca</span>, help__power
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** equal &amp; greater-than &amp; less-than</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"equal?"</span>, equal?
      <span class="comment">;; &lt;&lt; a, b -- a, b, true of false &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rbx</span>, <span class="variable-name">rax</span>
      <span class="builtin">sete</span>  <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"less-than?"</span>, less_than?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setl</span>  <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"greater-than?"</span>, greater_than?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setg</span>  <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack  <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"less-or-equal?"</span>, less_or_equal?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setle</span> <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

   define_primitive_function <span class="string">"greater-or-equal?"</span>, greater_or_equal?
      pop_argument_stack <span class="variable-name">rbx</span>
      pop_argument_stack <span class="variable-name">rax</span>
      <span class="builtin">cmp</span>   <span class="variable-name">rax</span>, <span class="variable-name">rbx</span>
      <span class="builtin">setge</span> <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** negative? &amp; positive?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"negative?"</span>, negative?
      <span class="comment">;; &lt;&lt; integer -- bool &gt;&gt;
</span>      <span class="type">xx</span> zero, less_than?
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"positive?"</span>, positive?
      <span class="comment">;; &lt;&lt; integer -- bool &gt;&gt;
</span>      <span class="type">xx</span> negative?, false?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* memory</span>
  * although the following functions are all side-effect
    but I use "save" instead of "save!"
<span class="org-block-begin-line">  #+begin_src fasm :tangle cicada-nymph.fasm
</span>  <span class="comment">;; "save" and "fetch" default to a jo_size
</span>  <span class="comment">;; the rule of "fetch2" and so on are:
</span>  <span class="comment">;;   in memory:
</span>  <span class="comment">;;     ||  1 : value-1  ||
</span>  <span class="comment">;;     ||  1 : value-2  ||
</span>  <span class="comment">;;     ||  1 : value-3  ||
</span>  <span class="comment">;;     ...
</span>  <span class="comment">;;   on stack:
</span>  <span class="comment">;;     &lt;&lt; value-1, value-2, value-3, ... &gt;&gt;
</span>  <span class="comment">;; of course we have:
</span>  <span class="comment">;;   fetch2 : memory=copy=&gt;stack
</span>  <span class="comment">;;   save2  : stack-&gt;memory
</span>
  define_primitive_function <span class="string">"save"</span>, save
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">qword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"save-byte"</span>, save_byte
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">byte</span>[<span class="variable-name">rbx</span>], <span class="variable-name">al</span>
     next

  define_primitive_function <span class="string">"save-two-bytes"</span>, save_two_bytes
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">word</span> [<span class="variable-name">rbx</span>], <span class="variable-name">ax</span>
     next

  define_primitive_function <span class="string">"save-four-bytes"</span>, save_four_bytes
     <span class="comment">;; ( value, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">dword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">eax</span>
     next

  define_primitive_function <span class="string">"n-save"</span>, n_save
     <span class="comment">;; &lt;&lt; value-n, ..., value-1, address, n -- &gt;&gt;
</span>     pop_argument_stack <span class="variable-name">rcx</span>
     pop_argument_stack <span class="variable-name">rdx</span>
     <span class="builtin">mov</span> <span class="variable-name">rax</span>, jo_size
     <span class="builtin">imul</span> <span class="variable-name">rax</span>, <span class="variable-name">rcx</span>
     <span class="builtin">add</span> <span class="variable-name">rdx</span>, <span class="variable-name">rax</span>
     <span class="comment">;; for address is based on 0
</span>     <span class="comment">;; but n is based on 1
</span>     <span class="builtin">sub</span> <span class="variable-name">rdx</span>, jo_size
  <span class="function-name">.loop</span>:
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">qword</span> [<span class="variable-name">rdx</span>], <span class="variable-name">rax</span>
     <span class="builtin">sub</span> <span class="variable-name">rdx</span>, jo_size
     <span class="builtin">loop</span> .loop
     next

  define_function <span class="string">"save2"</span>, save2
     <span class="comment">;; &lt;&lt; value-2, value-1, address -- &gt;&gt;
</span>     <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">2</span>
     <span class="type">xx</span> n_save
     <span class="type">xx</span> <span class="keyword">end</span>

  define_primitive_function <span class="string">"n-save-byte"</span>, n_save_byte
     <span class="comment">;; &lt;&lt; value-n, ..., value-1, address, n -- &gt;&gt;
</span>     pop_argument_stack <span class="variable-name">rcx</span>
     pop_argument_stack <span class="variable-name">rdx</span>
     <span class="builtin">add</span> <span class="variable-name">rdx</span>, <span class="variable-name">rcx</span>
     <span class="builtin">dec</span> <span class="variable-name">rdx</span>
  <span class="function-name">.loop</span>:
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="type">byte</span> [<span class="variable-name">rdx</span>], <span class="variable-name">al</span>
     <span class="builtin">dec</span> <span class="variable-name">rdx</span>
     <span class="builtin">loop</span> .loop
     next

  define_primitive_function <span class="string">"fetch"</span>, fetch
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack  <span class="variable-name">rbx</span>
     <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"fetch-byte"</span>, fetch_byte
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="variable-name">al</span>, <span class="type">byte</span>[<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"fetch-two-bytes"</span>, fetch_two_bytes
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="variable-name">ax</span>, <span class="type">word</span> [<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"fetch-four-bytes"</span>, fetch_four_bytes
     <span class="comment">;; ( address -- value )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
     <span class="builtin">mov</span> <span class="variable-name">eax</span>, <span class="type">dword</span> [<span class="variable-name">rbx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     next

  <span class="comment">;;   in memory:
</span>  <span class="comment">;;     ||  1 : value-1  ||
</span>  <span class="comment">;;     ...
</span>  <span class="comment">;;     ||  1 : value-n  ||
</span>  define_primitive_function <span class="string">"n-fetch"</span>, n_fetch
     <span class="comment">;; &lt;&lt; address, n -- value-1, ..., value-n &gt;&gt;
</span>     pop_argument_stack  <span class="variable-name">rcx</span>
     pop_argument_stack  <span class="variable-name">rdx</span>
  <span class="function-name">.loop</span>:
     <span class="builtin">mov</span> <span class="variable-name">rax</span>, <span class="type">qword</span> [<span class="variable-name">rdx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">add</span> <span class="variable-name">rdx</span>, jo_size
     <span class="builtin">loop</span> .loop
     next

  define_primitive_function <span class="string">"n-fetch-byte"</span>, n_fetch_byte
     <span class="comment">;; &lt;&lt; address, n -- byte-1, ..., byte-n &gt;&gt;
</span>     pop_argument_stack  <span class="variable-name">rcx</span>
     pop_argument_stack  <span class="variable-name">rdx</span>
     <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
  <span class="function-name">.loop</span>:
     <span class="builtin">mov</span> <span class="variable-name">al</span>, <span class="type">byte</span> [<span class="variable-name">rdx</span>]
     push_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">inc</span> <span class="variable-name">rdx</span>
     <span class="builtin">loop</span> .loop
     next

  define_function <span class="string">"fetch2"</span>, fetch2
     <span class="comment">;; &lt;&lt; address -- value-1, value-2 &gt;&gt;
</span>     <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">2</span>
     <span class="type">xx</span> n_fetch
     <span class="type">xx</span> <span class="keyword">end</span>

  define_primitive_function <span class="string">"add-save"</span>, add_save
     <span class="comment">;; ( number to add, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">add</span> <span class="type">qword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">rax</span>
     next

  define_primitive_function <span class="string">"sub-save"</span>, sub_save
     <span class="comment">;; ( number to add, address -- )
</span>     pop_argument_stack <span class="variable-name">rbx</span>
     pop_argument_stack <span class="variable-name">rax</span>
     <span class="builtin">sub</span> <span class="type">qword</span> [<span class="variable-name">rbx</span>], <span class="variable-name">rax</span>
     next
<span class="org-block-end-line">  #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* basic io</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> byte</span>
   * basic io is about byte
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** write-byte [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {


   <span class="function-name">buffer$write_byte</span>:
      <span class="type">db</span> <span class="constant">0</span>

   define_primitive_function <span class="string">"write-byte"</span>, write_byte
      <span class="comment">;; &lt;&lt; byte -- &gt;&gt;
</span>      <span class="comment">;; just calls the Linux write system call
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="comment">;; write can not just write the char in al to stdout
</span>      <span class="comment">;; write needs the address of the byte to write
</span>      <span class="builtin">mov</span> [buffer$write_byte], <span class="variable-name">al</span>

      <span class="comment">;;;; for linux
</span>      <span class="builtin">mov</span> linux64_sys_3_rdx, <span class="constant">1</span>                 <span class="comment">;; max length to be write
</span>      <span class="builtin">mov</span> linux64_sys_2_rsi, buffer$write_byte <span class="comment">;; address
</span>      <span class="builtin">mov</span> linux64_sys_1_rdi, <span class="constant">1</span>                 <span class="comment">;; stdout
</span>      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_write
      <span class="comment">;;;;
</span>
      <span class="builtin">syscall</span>
      next


      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** write-byte [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {


   <span class="function-name">buffer$write_byte</span>:
      <span class="type">db</span> <span class="constant">0</span>

   <span class="comment">;;;; for windows
</span>   _counter$write_byte:
      <span class="type">dq</span> <span class="constant">0</span>
   <span class="comment">;;;;
</span>
   define_primitive_function <span class="string">"write-byte"</span>, write_byte
      <span class="comment">;; &lt;&lt; byte -- &gt;&gt;
</span>      <span class="comment">;; just calls the Linux write system call
</span>      pop_argument_stack <span class="variable-name">rax</span>
      <span class="comment">;; write can not just write the char in al to stdout
</span>      <span class="comment">;; write needs the address of the byte to write
</span>      <span class="builtin">mov</span> [buffer$write_byte], <span class="variable-name">al</span>

   windows_function <span class="constant">5</span>
      <span class="builtin">push</span> <span class="constant">0</span>
      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">8</span>*<span class="constant">4</span>
      <span class="builtin">mov</span> windows64_fun_4_r9, _counter$write_byte
      <span class="builtin">mov</span> windows64_fun_3_r8, <span class="constant">1</span>
      <span class="builtin">mov</span> windows64_fun_2_rdx, buffer$write_byte
      <span class="builtin">mov</span> windows64_fun_1_rcx, [_output_handle]
      <span class="builtin">call</span> [WriteFile]
   end_windows_function

      next


   }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * calls the linux read system call to fill buffer$read_byte
   * do not exit the program
     when meeting &lt;end-of-file&gt;
     so
     when you hit &lt;C-d&gt;
     some you will not exit the interpreter
   * add the feature to unread one ket-char
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> factoring</span>
   * reading from file of stdin is slow
     thus
     1. when reading from file
        a whole file is readed at a time
        and saved to a buffer
     2. when reading from stdin
        a whole line is readed at a time
     3. not that
        reading line instead of keyboard-code
        will limit the design of the user interface
   * by factoring out the low-level calls
     that read a line from stdin
     we are able to implement eval-string easily
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> nested call of eval-string</span>
   * nested call of eval-string is handled
     by using a eval_string_stack
     to remember the old string
   * but
     in my view
     meta-programming should NOT
     be achieved by editing string
   * not that
     this point of view
     is not conflict with my macro system
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   max_input_length = <span class="constant">1024</span> * <span class="constant">1024</span>

   buffer$read_byte <span class="keyword">labeling</span>
      <span class="type">preserve</span> max_input_length
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** eval_string_stack</span>
<span class="org-level-3">*** </span><span class="org-todo">note</span>
    * for we do not build border-check
      into the interface of pop and push
      we allocation some memory below the stacks
    * the size$eval_string_stack
      defines the max depth
      of nested call to eval string
    * cursor and border of a evaled string
      can be stored in eval_string_stack
      so
      when evaling a string
      the eval_string_stack will be
      &lt;&lt; counter, cursor &gt;&gt;
      when evaling is nested depth is 2
      &lt;&lt; counter, cursor, counter, cursor &gt;&gt;
<span class="org-level-3">*** memory allocation</span>
<span class="org-block-begin-line">    #+begin_src fasm :tangle cicada-nymph.fasm
</span>    size$eval_string_stack = <span class="constant">1024</span> * jo_size

       <span class="type">preserve</span> <span class="constant">64</span> * jo_size
    address$eval_string_stack <span class="keyword">labeling</span>
       <span class="type">preserve</span> size$eval_string_stack
<span class="org-block-end-line">    #+end_src
</span><span class="org-level-3">*** pointer</span>
<span class="org-block-begin-line">    #+begin_src fasm :tangle cicada-nymph.fasm
</span>    <span class="function-name">pointer$eval_string_stack</span>:
       <span class="type">xx</span> address$eval_string_stack
<span class="org-block-end-line">    #+end_src
</span><span class="org-level-3">*** push &amp; pop</span>
<span class="org-block-begin-line">    #+begin_src fasm :tangle cicada-nymph.fasm
</span>    define_primitive_function <span class="string">"push-eval-string-stack"</span>, push_eval_string_stack
       <span class="comment">;; argument-stack -&gt; eval-string-stack
</span>       pop_argument_stack <span class="variable-name">rax</span>
       <span class="builtin">mov</span> <span class="variable-name">rbx</span>, [pointer$eval_string_stack]
       <span class="builtin">mov</span> [<span class="variable-name">rbx</span>], <span class="variable-name">rax</span>
       <span class="builtin">add</span> <span class="type">qword</span> [pointer$eval_string_stack], jo_size
       next

    define_primitive_function <span class="string">"pop-eval-string-stack"</span>, pop_eval_string_stack
       <span class="comment">;; eval-string-stack -&gt; argument-stack
</span>       <span class="builtin">sub</span> <span class="type">qword</span> [pointer$eval_string_stack], jo_size
       <span class="builtin">mov</span> <span class="variable-name">rbx</span>, [pointer$eval_string_stack]
       <span class="builtin">mov</span> <span class="variable-name">rax</span>, [<span class="variable-name">rbx</span>]
       push_argument_stack <span class="variable-name">rax</span>
       next
<span class="org-block-end-line">    #+end_src
</span><span class="org-level-3">*** clear</span>
<span class="org-block-begin-line">    #+begin_src fasm :tangle cicada-nymph.fasm
</span>    define_primitive_function <span class="string">"clear-eval-string-stack"</span>, clear_eval_string_stack
       <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>       <span class="builtin">mov</span> <span class="type">qword</span> [pointer$eval_string_stack], address$eval_string_stack
       next
<span class="org-block-end-line">    #+end_src
</span><span class="org-level-3">*** empty?</span>
<span class="org-block-begin-line">    #+begin_src fasm :tangle cicada-nymph.fasm
</span>    define_primitive_function <span class="string">"eval-string-stack-empty?"</span>, eval_string_stack_empty?
       <span class="comment">;; &lt;&lt; -- bool &gt;&gt;
</span>       <span class="builtin">mov</span> <span class="variable-name">rax</span>, [pointer$eval_string_stack]
       <span class="builtin">cmp</span> <span class="variable-name">rax</span>, address$eval_string_stack
       <span class="comment">;; less-than is treated as equal
</span>       <span class="builtin">setle</span> <span class="variable-name">al</span>
       <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
       push_argument_stack <span class="variable-name">rax</span>
       next
<span class="org-block-end-line">    #+end_src
</span><span class="org-level-2">** read-line-from-stdin [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   define_primitive_function <span class="string">"read-line-from-stdin"</span>, read_line_from_stdin
      <span class="comment">;; &lt;&lt; buffer address, max length -- &gt;&gt;
</span>      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_2_rsi
      <span class="builtin">xor</span> linux64_sys_1_rdi, linux64_sys_1_rdi <span class="comment">;; stdin
</span>      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_read
      <span class="builtin">syscall</span>
      <span class="comment">;; the return value
</span>      <span class="comment">;; is a count of the number of bytes transferred
</span>      push_argument_stack <span class="variable-name">rax</span>
      next

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">""</span>, test__read_line_from_stdin
      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$read_byte
      <span class="type">xx</span> <span class="keyword">literal</span>, max_input_length
      <span class="type">xx</span> read_line_from_stdin
      <span class="type">xx</span> pretty_write_integer
      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$read_byte
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>
      <span class="type">xx</span> write_string
      <span class="type">xx</span> exit_with_TOS
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-line-from-stdin [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {


   _counter$read_byte:
      <span class="type">dq</span> <span class="constant">0</span>

   define_primitive_function <span class="string">"read-line-from-stdin"</span>, read_line_from_stdin
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>
   windows_function <span class="constant">5</span>
      <span class="builtin">push</span> <span class="constant">0</span>
      <span class="builtin">sub</span> <span class="variable-name">rsp</span>, <span class="constant">8</span>*<span class="constant">4</span>
      <span class="builtin">mov</span> windows64_fun_4_r9, _counter$read_byte
      <span class="builtin">mov</span> windows64_fun_3_r8, max_input_length
      <span class="builtin">mov</span> windows64_fun_2_rdx, buffer$read_byte
      <span class="builtin">mov</span> windows64_fun_1_rcx, [_input_handle]
      <span class="builtin">call</span> [ReadFile]
   end_windows_function

      <span class="comment">;; the return value
</span>      <span class="comment">;; is a count of the number of bytes transferred
</span>      <span class="builtin">mov</span> <span class="variable-name">rax</span>, [_counter$read_byte]
      push_argument_stack <span class="variable-name">rax</span>
      next


      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-byte</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-byte"</span>, read_byte
      <span class="comment">;; &lt;&lt; -- byte &gt;&gt;
</span>      <span class="type">xx</span> have_unreaded_ket_char?, <span class="keyword">false?branch</span>, <span class="constant">9</span>
      <span class="type">xx</span>   <span class="keyword">literal</span>, char$unreaded_ket_char, fetch_byte
      <span class="type">xx</span>   zero, <span class="keyword">literal</span>, flag$unreaded_ket_char
      <span class="type">xx</span>   save
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> read_byte__without_unread
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"read-byte,without-unread"</span>, read_byte__without_unread
      <span class="comment">;; &lt;&lt; -- byte &gt;&gt;
</span>      <span class="type">xx</span> eval_string_stack_empty?, <span class="keyword">false?branch</span>, (.not_empty-$)/jo_size
      <span class="type">xx</span>   <span class="keyword">literal</span>, buffer$read_byte
      <span class="type">xx</span>   <span class="keyword">literal</span>, max_input_length
      <span class="type">xx</span>   read_line_from_stdin
      <span class="type">xx</span>     <span class="keyword">dup</span>, positive?, false?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="comment">;;     ignore &lt;end-of-file&gt;
</span>      <span class="comment">;;     ignore reading error
</span>      <span class="type">xx</span>     drop
      <span class="type">xx</span>     <span class="keyword">taca</span>, read_byte__without_unread
      <span class="type">xx</span>   push_eval_string_stack
      <span class="type">xx</span>   <span class="keyword">literal</span>, buffer$read_byte
      <span class="type">xx</span>   push_eval_string_stack
      <span class="type">xx</span>   <span class="keyword">taca</span>, read_byte__without_unread
      <span class="function-name">.not_empty</span>:
      <span class="type">xx</span> pop_eval_string_stack
      <span class="type">xx</span> pop_eval_string_stack
      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   <span class="keyword">taca</span>, read_byte__without_unread
      <span class="type">xx</span> sub1, push_eval_string_stack
      <span class="type">xx</span> <span class="keyword">dup</span>
      <span class="type">xx</span> add1, push_eval_string_stack
      <span class="type">xx</span> fetch_byte
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** unread-ket-char</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">flag$unreaded_ket_char</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   <span class="function-name">char$unreaded_ket_char</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   define_function <span class="string">"have-unreaded-ket-char?"</span>, have_unreaded_ket_char?
      <span class="comment">;; &lt;&lt; -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, flag$unreaded_ket_char
      <span class="type">xx</span> fetch
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"unread-ket-char"</span>, unread_ket_char
      <span class="comment">;; &lt;&lt; char -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, char$unreaded_ket_char, save
      <span class="type">xx</span> true, <span class="keyword">literal</span>, flag$unreaded_ket_char
      <span class="type">xx</span> save
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* eval-string</span>
<span class="org-block-begin-line">  #+begin_src fasm :tangle cicada-nymph.fasm
</span>  define_function <span class="string">"eval-string"</span>, eval_string
     <span class="comment">;; &lt;&lt; string[address, length] -- UNKNOWN &gt;&gt;
</span>     <span class="type">xx</span> push_eval_string_stack
     <span class="type">xx</span> push_eval_string_stack
     <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">  #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* file io</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** open-file,to-read [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   name_buffer$open_file__to_read <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">512</span>

   define_primitive_function <span class="string">"open-file,to-read"</span>, open_file__to_read
      <span class="comment">;; &lt;&lt; file-name-string[address, length] --
</span>      <span class="comment">;;    [file handle] or [negate number on error] &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rsi</span>
      <span class="comment">;; copy file-name as a null-terminal string
</span>      <span class="builtin">mov</span> <span class="variable-name">rdi</span>, name_buffer$open_file__to_read
      <span class="builtin">rep</span> <span class="builtin">movsb</span>
      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">mov</span> <span class="type">byte</span> [<span class="variable-name">rdi</span>], <span class="variable-name">al</span>
      <span class="builtin">mov</span> linux64_sys_2_rsi, open_read <span class="comment">;; read onlya
</span>      <span class="builtin">mov</span> linux64_sys_1_rdi, name_buffer$open_file__to_read
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_open
      <span class="builtin">syscall</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** open-file,to-write [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   name_buffer$open_file__to_write <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">512</span>

   define_primitive_function <span class="string">"open-file,to-write"</span>, open_file__to_write
      <span class="comment">;; &lt;&lt; file-name-string[address, length] --
</span>      <span class="comment">;;    [file handle] or [negate number on error] &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rsi</span>
      <span class="comment">;; copy file-name as a null-terminal string
</span>      <span class="builtin">mov</span> <span class="variable-name">rdi</span>, name_buffer$open_file__to_write
      <span class="builtin">rep</span> <span class="builtin">movsb</span>
      <span class="builtin">xor</span> <span class="variable-name">rax</span>, <span class="variable-name">rax</span>
      <span class="builtin">mov</span> <span class="type">byte</span> [<span class="variable-name">rdi</span>], <span class="variable-name">al</span>
      <span class="builtin">mov</span> linux64_sys_3_rdx, <span class="constant">110100100b</span>
      <span class="builtin">mov</span> linux64_sys_2_rsi, open_readAndWrite <span class="builtin">or</span> open_creat <span class="builtin">or</span> open_rewrite
      <span class="builtin">mov</span> linux64_sys_1_rdi, name_buffer$open_file__to_write
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_open
      <span class="builtin">syscall</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** close-file [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   define_primitive_function <span class="string">"close-file"</span>, close_file
      <span class="comment">;; &lt;&lt; file-handle -- &gt;&gt;
</span>      pop_argument_stack linux64_sys_1_rdi
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_close
      <span class="builtin">syscall</span>
      next

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-file [linux64]</span>
   * from disk to memory
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   define_primitive_function <span class="string">"read-file"</span>, read_file
      <span class="comment">;; &lt;&lt; [file handle], buffer[address, length] --
</span>      <span class="comment">;;    [number of char] or [negate number on error] &gt;&gt;
</span>      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_1_rdi
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_read
      <span class="builtin">syscall</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** write-file [linux64]</span>
   * from memory to disk
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {

   define_primitive_function <span class="string">"write-file"</span>, write_file
      <span class="comment">;; &lt;&lt; [file handle], buffer[address, length] --
</span>      <span class="comment">;;    [number of char] or [negate number on error] &gt;&gt;
</span>      pop_argument_stack linux64_sys_3_rdx
      pop_argument_stack linux64_sys_2_rsi
      pop_argument_stack linux64_sys_1_rdi
      <span class="builtin">mov</span> linux64_sys_n_rax, linux64_syscall_write
      <span class="builtin">syscall</span>
      push_argument_stack <span class="variable-name">rax</span>
      next

      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">&gt;&lt;</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* load-file</span>
  * load-file can not be nested for now
    a stack of buffer would solve this problem
<span class="org-block-begin-line">  #+begin_src fasm :tangle cicada-nymph.fasm
</span>  buffer$load_file <span class="keyword">labeling</span>
    <span class="type">preserve</span> <span class="constant">1024</span> * <span class="constant">1024</span>

  define_function <span class="string">"load-file"</span>, load_file
     <span class="comment">;; &lt;&lt; name-string[address, length] -- UNKNOWN &gt;&gt;
</span>     <span class="type">xx</span> open_file__to_read
     <span class="type">xx</span> <span class="keyword">dup</span>
     <span class="type">xx</span>   <span class="keyword">literal</span>, buffer$load_file <span class="comment">;; buffer
</span>     <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="constant">1024</span> * <span class="constant">1024</span>      <span class="comment">;; length
</span>     <span class="type">xx</span>   read_file
     <span class="type">xx</span> swap, close_file
     <span class="type">xx</span> <span class="keyword">dup</span>, positive?, <span class="keyword">false?branch</span>, (.error-$)/jo_size
     <span class="type">xx</span>   <span class="keyword">literal</span>, buffer$load_file
     <span class="type">xx</span>   swap
     <span class="type">xx</span>   push_eval_string_stack
     <span class="type">xx</span>   push_eval_string_stack
     <span class="type">xx</span>   <span class="keyword">end</span>
     <span class="function-name">.error</span>:
     <span class="type">xx</span> error_report__load_file
     <span class="type">xx</span> write_integer
     <span class="type">xx</span> <span class="keyword">end</span>

  define_function <span class="string">"error-report,load-file"</span>, error_report__load_file
     <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>     <span class="type">xx</span> <span class="keyword">literal</span>, string$error_report__load_file
     <span class="type">xx</span> <span class="keyword">literal</span>, length$error_report__load_file
     <span class="type">xx</span> write_string
     <span class="type">xx</span> <span class="keyword">end</span>

  <span class="function-name">string$error_report__load_file</span>:
     <span class="type">db</span> <span class="string">"* (load-file) MEETS ERROR : "</span>
  <span class="function-name">.end</span>:
  length$error_report__load_file = (.end - string$error_report__load_file)
<span class="org-block-end-line">  #+end_src
</span><span class="org-level-1">* load-init-file</span>
<span class="org-block-begin-line">  #+begin_src fasm :tangle cicada-nymph.fasm
</span>  <span class="function-name">string$name_of_init_file</span>:
     <span class="type">db</span> <span class="string">"core.cn"</span>
  <span class="function-name">.end</span>:
  length$name_of_init_file = (.end - string$name_of_init_file)


  define_function <span class="string">"load-init-file"</span>, load_init_file
     <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>     <span class="type">xx</span> <span class="keyword">literal</span>, string$name_of_init_file
     <span class="type">xx</span> <span class="keyword">literal</span>, length$name_of_init_file
     <span class="type">xx</span> load_file
     <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">  #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* char</span>
<span class="org-level-2">** space-char?</span>
   * as for space-char
     I only use two
     ASCII 10 (newline)
     ASCII 32 (whitespace)
   * note that
     I use the term "whitespace" to denotes the char
     I use the term "space" to denotes the set of chars
   * I will simply view number less-or-equal 32 as space-char
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"space-char?"</span>, space_char?
      <span class="comment">;; &lt;&lt; char -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">32</span>
      <span class="type">xx</span> less_or_equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** bar-ket-char?</span>
   * () [] {}
     but not &lt;&gt;
   * double-quote is viewed as special bar-ket-char
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"bar-ket-char?"</span>, bar_ket_char?
      <span class="comment">;; &lt;&lt; char -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">'('</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">')'</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">'['</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">']'</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">'{'</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">'}'</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">'"'</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> drop, false
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** decimal-digital-char?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"digital-char?"</span>, decimal_digital_char?
      <span class="comment">;; &lt;&lt; char -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">'0'</span>, less_than?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="default">'9'</span>, less_or_equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> drop, false
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> digital</span>
   * a decimal-digital is number from 0 to 9
   * a binary-digital is number from 0 to 1
<span class="org-level-2">** char-&gt;decimal-digital &amp; decimal-digital-&gt;char</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"char-&gt;decimal-digital"</span>, char_to_decimal_digital
      <span class="comment">;; &lt;&lt; char -- decimal-digital &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="default">'0'</span>
      <span class="type">xx</span> subtraction
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"decimal-digital-&gt;char"</span>, decimal_digital_to_char
      <span class="comment">;; &lt;&lt; decimal-digital -- char &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="default">'0'</span>
      <span class="type">xx</span> addition
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* buffer</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * a buffer is a large vector
     and some functions do not care about how large it is
<span class="org-level-2">** compare-buffer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; return false when length == 0
</span>   define_primitive_function <span class="string">"compare-buffer"</span>, compare_buffer
      <span class="comment">;; &lt;&lt; address, address, length -- bool &gt;&gt;
</span>      pop_argument_stack <span class="variable-name">rcx</span>
      pop_argument_stack <span class="variable-name">rdi</span>
      pop_argument_stack <span class="variable-name">rsi</span>
      <span class="builtin">repe</span> <span class="builtin">cmpsb</span>
      <span class="builtin">sete</span> <span class="variable-name">al</span>
      <span class="builtin">movzx</span> <span class="variable-name">rax</span>, <span class="variable-name">al</span>
      push_argument_stack <span class="variable-name">rax</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* string</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> io about string</span>
<span class="org-level-2">** write-string</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"write-string"</span>, write_string
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> sub1, swap
      <span class="type">xx</span> <span class="keyword">dup</span>, fetch_byte, write_byte
      <span class="type">xx</span> add1, swap
      <span class="type">xx</span> <span class="keyword">taca</span>, write_string
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** pretty_write_string</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">".s"</span>, pretty_write_string
      <span class="comment">;; &lt;&lt; integer -- &gt;&gt;
</span>      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>
      <span class="type">xx</span> write_byte
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** string-equal?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-equal?"</span>, string_equal?
      <span class="comment">;; &lt;&lt; string[address, length], string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> xoverxx, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   swap
      <span class="type">xx</span>   compare_buffer
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> drop, drop2
      <span class="type">xx</span> false
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-[head|tail],char</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-head,char"</span>, string_head__char
      <span class="comment">;; &lt;&lt; string[address, length] -- char &gt;&gt;
</span>      <span class="type">xx</span> drop, fetch_byte
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"string-tail,char"</span>, string_tail__char
      <span class="comment">;; &lt;&lt; string[address, length] -- [address + 1, length + 1] &gt;&gt;
</span>      <span class="type">xx</span> sub1, swap
      <span class="type">xx</span> add1
      <span class="type">xx</span> swap
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-&gt;buffer!</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_primitive_function <span class="string">"string-&gt;buffer!"</span>, string_to_buffer!
      <span class="comment">;; ( string[address, length], buffer[address] -- )
</span>      pop_argument_stack <span class="variable-name">rdi</span> <span class="comment">;; destination
</span>      pop_argument_stack <span class="variable-name">rcx</span> <span class="comment">;; counter
</span>      pop_argument_stack <span class="variable-name">rsi</span> <span class="comment">;; source
</span>      <span class="builtin">rep</span> <span class="builtin">movsb</span>
      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-reverse!</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   buffer$string_reverse! <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span>


   define_primitive_function <span class="string">"string-reverse!"</span>, string_reverse!
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="builtin">mov</span> <span class="variable-name">rdi</span>, buffer$string_reverse!
      <span class="builtin">mov</span> <span class="variable-name">rcx</span>, [pointer$argument_stack - (<span class="constant">1</span> * jo_size)]
      <span class="builtin">mov</span> <span class="variable-name">rsi</span>, [pointer$argument_stack - (<span class="constant">2</span> * jo_size)]
      <span class="builtin">rep</span> <span class="builtin">movsb</span>

      <span class="builtin">mov</span> <span class="variable-name">rcx</span>, [pointer$argument_stack - (<span class="constant">1</span> * jo_size)]
      <span class="builtin">dec</span> <span class="variable-name">rdi</span> <span class="comment">;; cursor back into string in buffer$string_reverse!
</span>      <span class="builtin">mov</span> <span class="variable-name">rsi</span>, [pointer$argument_stack - (<span class="constant">2</span> * jo_size)]
   <span class="function-name">.loop</span>:
      <span class="builtin">mov</span> <span class="variable-name">al</span>, <span class="type">byte</span> [<span class="variable-name">rdi</span>]
      <span class="builtin">mov</span> <span class="type">byte</span> [<span class="variable-name">rsi</span>], <span class="variable-name">al</span>
      <span class="builtin">dec</span> <span class="variable-name">rdi</span>
      <span class="builtin">inc</span> <span class="variable-name">rsi</span>
      <span class="builtin">loop</span> .loop

      next
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** digital-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"digital-string?"</span>, digital_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> over, fetch_byte, decimal_digital_char?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   string_tail__char
      <span class="type">xx</span>   <span class="keyword">taca</span>, digital_string?
      <span class="type">xx</span> drop2, false
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** char-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"char-string?"</span>, char_string?
      <span class="comment">;; &lt;&lt; string[address, length], char -- bool &gt;&gt;
</span>      <span class="type">xx</span> xxswapx
      <span class="type">xx</span> <span class="keyword">dup</span>, one?, false?, <span class="keyword">false?branch</span>, <span class="constant">5</span>
      <span class="type">xx</span>   drop2, drop
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> string_head__char, equal?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> false
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** zero-string?</span>
   * "0" or "-0"
     0 is special when compiling literal number
     for we are using 0 as "end"
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"zero-string?"</span>, zero_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> dup2, <span class="keyword">literal</span>, <span class="default">'0'</span>, char_string?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_head__char, <span class="keyword">literal</span>, <span class="default">'-'</span>, equal?, false?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> string_tail__char, <span class="keyword">literal</span>, <span class="default">'0'</span>, char_string?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** integer-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"integer-string?"</span>, integer_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2, <span class="keyword">literal</span>, <span class="default">'-'</span>, char_string?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2, string_head__char, <span class="keyword">literal</span>, <span class="default">'-'</span>, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   string_tail__char
      <span class="type">xx</span>   digital_string?
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> digital_string?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-&gt;integer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-&gt;integer"</span>, string_to_integer
      <span class="comment">;; &lt;&lt; string[address, length] -- integer &gt;&gt;
</span>      <span class="type">xx</span> dup2, string_head__char, <span class="keyword">literal</span>, <span class="default">'-'</span>, equal?, false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   digital_string_to_integer
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> digital_string_to_integer
      <span class="type">xx</span> negate
      <span class="type">xx</span> <span class="keyword">end</span>


   <span class="function-name">sum$digital_string_to_integer</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   <span class="function-name">counter$digital_string_to_integer</span>:
      <span class="type">xx</span> <span class="constant">0</span>

   define_function <span class="string">"digital-string-&gt;integer"</span>, digital_string_to_integer
      <span class="comment">;; &lt;&lt; string[address, length] -- integer &gt;&gt;
</span>      <span class="type">xx</span> zero, <span class="keyword">literal</span>, sum$digital_string_to_integer, save
      <span class="type">xx</span> zero, <span class="keyword">literal</span>, counter$digital_string_to_integer, save

      <span class="type">xx</span> dup2, string_reverse!
      <span class="type">xx</span>   help__digital_string_to_integer
      <span class="type">xx</span> string_reverse!, drop2

      <span class="type">xx</span> <span class="keyword">literal</span>, sum$digital_string_to_integer
      <span class="type">xx</span> fetch
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"help,digital-string-&gt;integer"</span>, help__digital_string_to_integer
      <span class="comment">;; &lt;&lt; reversed-string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="type">xx</span> dup2, string_head__char, char_to_decimal_digital
      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="constant">10</span>
      <span class="type">xx</span>   <span class="keyword">literal</span>, counter$digital_string_to_integer, fetch
      <span class="type">xx</span>     one
      <span class="type">xx</span>     <span class="keyword">literal</span>, counter$digital_string_to_integer
      <span class="type">xx</span>     add_save
      <span class="type">xx</span>   power
      <span class="type">xx</span> multiple

      <span class="type">xx</span> <span class="keyword">literal</span>, sum$digital_string_to_integer
      <span class="type">xx</span> add_save

      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> <span class="keyword">taca</span>, help__digital_string_to_integer
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** find-char,string</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"find-char,string"</span>, find_char__string
     <span class="comment">;; &lt;&lt; found:
</span>     <span class="comment">;;      string[address, length], char -- address, true &gt;&gt;
</span>     <span class="comment">;; &lt;&lt; not found:
</span>     <span class="comment">;;      string[address, length], char -- false &gt;&gt;
</span>     <span class="type">xx</span> over, zero?, <span class="keyword">false?branch</span>, <span class="constant">5</span>
     <span class="type">xx</span>   drop, drop2
     <span class="type">xx</span>   false
     <span class="type">xx</span>   <span class="keyword">end</span>
     <span class="type">xx</span> xoverxx, fetch_byte
     <span class="type">xx</span> over, equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
     <span class="type">xx</span>   drop2
     <span class="type">xx</span>   true
     <span class="type">xx</span>   <span class="keyword">end</span>
     <span class="type">xx</span> xxswapx
     <span class="type">xx</span> string_tail__char
     <span class="type">xx</span> xswapxx
     <span class="type">xx</span> <span class="keyword">taca</span>, find_char__string
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src cicada-nymph
</span>   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">XIE</span> Yuheng <span class="cicada-nymph-sentence-reader">;</span>
   <span class="cicada-nymph-number">32</span> find-char,string . <span class="cicada-nymph-comment">&lt;&lt; 1 &gt;&gt;</span>
   fetch-byte . <span class="cicada-nymph-comment">&lt;&lt; 32 &gt;&gt;</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* io about number</span>
<span class="org-level-2">** write-nature-number</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="comment">;; 2 ^ 64 = 18446744073709551616
</span>   <span class="comment">;; which is of length 20
</span>   <span class="comment">;; so
</span>   <span class="comment">;; I use 32 to align to 16
</span>
   buffer$write_nature_number <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">32</span>

   <span class="function-name">counter$write_nature_number</span>:
      <span class="type">xx</span> <span class="constant">0</span>


   define_function <span class="string">"write-nature-number"</span>, write_nature_number
      <span class="comment">;; &lt;&lt; nature-number -- &gt;&gt;
</span>      <span class="type">xx</span> zero
      <span class="type">xx</span> <span class="keyword">literal</span>, counter$write_nature_number, save

      <span class="type">xx</span> help__write_nature_number

      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$write_nature_number
      <span class="type">xx</span> <span class="keyword">literal</span>, counter$write_nature_number, fetch
      <span class="type">xx</span> string_reverse!
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>


   define_function <span class="string">"help,write-nature-number"</span>, help__write_nature_number
      <span class="comment">;; &lt;&lt; rest-number -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>, divmod

      <span class="type">xx</span> decimal_digital_to_char
      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$write_nature_number
      <span class="type">xx</span> <span class="keyword">literal</span>, counter$write_nature_number, fetch
      <span class="type">xx</span> addition
      <span class="type">xx</span> save_byte

      <span class="type">xx</span> one
      <span class="type">xx</span> <span class="keyword">literal</span>, counter$write_nature_number
      <span class="type">xx</span> add_save

      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   drop
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">taca</span>, help__write_nature_number
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** write-integer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"write-integer"</span>, write_integer
      <span class="comment">;; &lt;&lt; integer -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, positive?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   write_nature_number
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="default">'-'</span>, write_byte
      <span class="type">xx</span> negate
      <span class="type">xx</span> write_nature_number
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** pretty_write_integer</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"."</span>, pretty_write_integer
      <span class="comment">;; &lt;&lt; integer -- &gt;&gt;
</span>      <span class="type">xx</span> write_integer
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">32</span>
      <span class="type">xx</span> write_byte
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* word</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> io about word</span>
   * words are separated by spaces
   * a bar-ket is a word
     even when there are no spaces around it
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   max_word_length = <span class="constant">1024</span>

   buffer$read_word <span class="keyword">labeling</span>
      <span class="type">preserve</span> max_word_length

   buffer$read_word_for_REPL <span class="keyword">labeling</span>
      <span class="type">preserve</span> max_word_length
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word-begin-char</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word-begin-char"</span>, read_word_begin_char
      <span class="comment">;; &lt;&lt; -- non-blank-char &gt;&gt;
</span>      <span class="type">xx</span> read_byte
      <span class="type">xx</span> <span class="keyword">dup</span>, <span class="keyword">literal</span>, <span class="constant">32</span> <span class="comment">;; ascii.space
</span>      <span class="type">xx</span> greater_than?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> drop
      <span class="type">xx</span> <span class="keyword">taca</span>, read_word_begin_char
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word-&gt;buffer</span>
   1. skip any space-char (whitespace newline)
   2. call read_char to read characters into buffer
      until it hits a blank
   3. return the address of buffer and length to argument_stack
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word-&gt;buffer"</span>, read_word_to_buffer
      <span class="comment">;; &lt;&lt; buffer -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> read_word_begin_char
      <span class="comment">;; no metter what the begin char is
</span>      <span class="comment">;; save it into buffer
</span>      <span class="type">xx</span> dup2, swap, save_byte
      <span class="type">xx</span> swap, add1, swap
      <span class="type">xx</span> one, swap <span class="comment">;; leave length counter
</span>      <span class="comment">;; &lt;&lt; cursor[address in buffer], counter, begin char &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, bar_ket_char?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop
      <span class="type">xx</span>   help__read_word_to_buffer__bar_ket
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="comment">;; maybe add other type of chars
</span>      <span class="type">xx</span> drop
      <span class="type">xx</span> help__read_word_to_buffer__regular
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"help,read-word-&gt;buffer,bar-ket"</span>, help__read_word_to_buffer__bar_ket
      <span class="comment">;; &lt;&lt; cursor[address in buffer], counter -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> tuck, subtraction
      <span class="type">xx</span> swap
      <span class="type">xx</span> <span class="keyword">end</span>


   define_function <span class="string">"help,read-word-&gt;buffer,regular"</span>, help__read_word_to_buffer__regular
      <span class="comment">;; &lt;&lt; cursor[address in buffer], counter -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> read_byte
      <span class="type">xx</span> <span class="keyword">dup</span>, bar_ket_char?, <span class="keyword">false?branch</span>, <span class="constant">6</span>
      <span class="type">xx</span>   unread_ket_char
      <span class="type">xx</span>   tuck, subtraction
      <span class="type">xx</span>   swap
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">dup</span>, space_char?, <span class="keyword">false?branch</span>, <span class="constant">6</span>
      <span class="type">xx</span>   drop
      <span class="type">xx</span>   tuck, subtraction
      <span class="type">xx</span>   swap
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> xoverxx, save_byte
      <span class="type">xx</span> add1
      <span class="type">xx</span> swap, add1, swap
      <span class="type">xx</span> <span class="keyword">taca</span>, help__read_word_to_buffer__regular
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word</span>
   * read-word will override the word readed before
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word"</span>, read_word
      <span class="comment">;; &lt;&lt; -- word[address of buffer$read_word, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$read_word, read_word_to_buffer
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** read-word-for-REPL</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"read-word-for-REPL"</span>, read_word_for_REPL
      <span class="comment">;; &lt;&lt; -- word[address of buffer$read_word_for_REPL, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$read_word_for_REPL, read_word_to_buffer
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * one should use space-string? to make sure
     that the string is not space-string
     before apply string-[head|tail],word onto the string
<span class="org-level-2">** space-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"space-string?"</span>, space_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2, string_head__char, space_char?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   string_tail__char
      <span class="type">xx</span>   <span class="keyword">taca</span>, space_string?
      <span class="type">xx</span> drop2, false
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-&gt;word-[begin|end]</span>
   * the error is not handled
     so
     before calling (string-&gt;word-begin)
     one should make sure that
     the argument is not a space-string
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-&gt;word-begin"</span>, string_to_word_begin
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="comment">;;   no error handling
</span>      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2, string_head__char
      <span class="type">xx</span> space_char?, false?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> <span class="keyword">taca</span>, string_to_word_begin

   define_function <span class="string">"string-&gt;word-end"</span>, string_to_word_end
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="comment">;;   no error handling
</span>      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2, string_head__char
      <span class="type">xx</span> bar_ket_char?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   string_tail__char
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> help__string_to_word_end
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"help,string-&gt;word-end"</span>, help__string_to_word_end
      <span class="comment">;; &lt;&lt; string[address, length] -- address &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, zero?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="comment">;;   no error handling
</span>      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2, string_head__char
      <span class="type">xx</span> space_char?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2, string_head__char
      <span class="type">xx</span> bar_ket_char?, <span class="keyword">false?branch</span>, <span class="constant">2</span>
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> string_tail__char
      <span class="type">xx</span> <span class="keyword">taca</span>, help__string_to_word_end
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** string-[head|tail],word</span>
   * note that
     the following functions do not create new strings
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"string-head,word"</span>, string_head__word
      <span class="comment">;; &lt;&lt; string[address, length] -- word[address, length] &gt;&gt;
</span>      <span class="type">xx</span> string_to_word_begin
      <span class="type">xx</span> dup2, string_to_word_end
      <span class="type">xx</span> swap, drop
      <span class="type">xx</span> subtraction
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"string-tail,word"</span>, string_tail__word
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> string_to_word_begin
      <span class="type">xx</span> string_to_word_end
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* dictionary</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * the dictionary is a single-linked-list
     of word-jo-jojo
   * a jojo is an vector of jo
   * from a jo one can find a jojo
     for example
     this is what the "explain$function" will do
     to help the interpreter
     to explain the mean of a jo
   * from a word one can find a jo
     for example
     this is what the "define-function" will do
     from source code
     it defines new function into dictionary
     by creating new structured data into memory
<span class="org-level-2">** find</span>
   * as find
   * find jo in dictionary by word
     but I simply call it "find"
   * a function whoes name is prefixed by "find"
     maybe fail to find
     and maybe returns a signal
     to inform the function who calls it
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*first-jo-in-dictionary*"</span>, V__first_jo_in_dictionary
      <span class="type">xx</span> last_link + jo_size

   define_function <span class="string">"find"</span>, find
      <span class="comment">;; found :
</span>      <span class="comment">;; &lt;&lt; word[address, length] -- jo, true &gt;&gt;
</span>      <span class="comment">;; not found :
</span>      <span class="comment">;; &lt;&lt; word[address, length] -- false &gt;&gt;
</span>      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> help__find
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"help,find"</span>, help__find
      <span class="comment">;; found :
</span>      <span class="comment">;; &lt;&lt; word[address, length], jo -- jo, true &gt;&gt;
</span>      <span class="comment">;; not found :
</span>      <span class="comment">;; &lt;&lt; word[address, length], jo -- false &gt;&gt;
</span>      <span class="type">xx</span> xxtuckx
      <span class="type">xx</span> jo_to_name, xxoverxx
      <span class="type">xx</span> string_equal?, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   drop2, true
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> xswapxx
      <span class="type">xx</span> <span class="keyword">dup</span>, last_jo__dictionary?, <span class="keyword">false?branch</span>, <span class="constant">5</span>
      <span class="type">xx</span>   drop, drop2
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> jo_to_pre_jo
      <span class="type">xx</span> <span class="keyword">taca</span>, help__find
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** execute-word</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"execute-word"</span>, execute_word
      <span class="comment">;; &lt;&lt; word[address, length] -- unknown &gt;&gt;
</span>      <span class="type">xx</span> dup2, integer_string?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   string_to_integer
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="comment">;; maybe more
</span>
      <span class="type">xx</span> dup2 <span class="comment">;; for to report undefined word
</span>
      <span class="type">xx</span> find, <span class="keyword">false?branch</span>, <span class="constant">5</span>
      <span class="type">xx</span>   xxswapx, drop2
      <span class="type">xx</span>   execute_jo
      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="type">xx</span> write_undefined_word_report__for_execute_word
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>
      <span class="type">xx</span> write_byte
      <span class="type">xx</span> <span class="keyword">end</span>


   define_function <span class="string">"write-undefined-word-report,for-execute-word"</span>, write_undefined_word_report__for_execute_word
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$undefined_word_report__for_execute_word
      <span class="type">xx</span> <span class="keyword">literal</span>, length$undefined_word_report__for_execute_word
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>

   <span class="function-name">string$undefined_word_report__for_execute_word</span>:
      <span class="type">db</span> <span class="string">"* (execute-word) MEETS UNDEFINED WORD : "</span>
   <span class="function-name">.end</span>:
   length$undefined_word_report__for_execute_word = (.end - string$undefined_word_report__for_execute_word)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* basic-REPL</span>
<span class="org-block-begin-line">  #+begin_src fasm :tangle cicada-nymph.fasm
</span>  define_function <span class="string">"basic-REPL"</span>, basic_REPL
     <span class="comment">;; &lt;&lt; UNKNOWN -- UNKNOWN &gt;&gt;
</span>     <span class="type">xx</span> read_word_for_REPL
     <span class="type">xx</span> execute_word
     <span class="type">xx</span> <span class="keyword">taca</span>, basic_REPL
<span class="org-block-end-line">  #+end_src
</span><span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* colon semicolon</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * from the aesthetics point of view
     I do NOT think which of the following is better then the other
     but I choose the second one
   * first:
<span class="org-block-begin-line">     #+begin_src
</span><span class="org-block">     define-function factorial
       &lt;&lt; n -- n! &gt;&gt;
       dup one? if
         end
       then
       dup sub1 factorial *
       end
     end
</span><span class="org-block-end-line">     #+end_src
</span>   * second:
<span class="org-block-begin-line">     #+begin_src cicada-nymph
</span>     <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">factorial</span>
       <span class="cicada-nymph-comment">&lt;&lt; n -- n! &gt;&gt;</span>
       dup one? <span class="cicada-nymph-syntax-key-word">if</span>
         <span class="cicada-nymph-end">end</span>
       <span class="cicada-nymph-syntax-key-word">then</span>
       dup sub1 factorial *
       <span class="cicada-nymph-end">end</span>
     <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
<span class="org-block-end-line">     #+end_src
</span><span class="org-level-2">** [colon|semicolon]-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"colon-string?"</span>, colon_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="default">':'</span>
      <span class="type">xx</span> char_string?
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">"semicolon-string?"</span>, semicolon_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="default">';'</span>
      <span class="type">xx</span> char_string?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** comment-[begin|end]-string?</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="function-name">string$comment_begin</span>:
      <span class="type">db</span> <span class="string">"&lt;&lt;"</span>

   define_function <span class="string">"comment-begin-string?"</span>, comment_begin_string?
      <span class="comment">;; &lt;&lt; string[address, length] -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$comment_begin
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">2</span>
      <span class="type">xx</span> string_equal?
      <span class="type">xx</span> <span class="keyword">end</span>


   <span class="function-name">string$comment_end</span>:
      <span class="type">db</span> <span class="string">"&gt;&gt;"</span>

   define_function <span class="string">"comment-end-string?"</span>, comment_end_string?
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$comment_end
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">2</span>
      <span class="type">xx</span> string_equal?
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** colon &amp; semicolon</span>
   * nested : ; is NOT allow
     and no error check for it
   * nested &lt;&lt; &gt;&gt; must be handled
   * comment are handled by : ;
     comment inside : ; are not readed
   * note that
     there might be a ; in &lt;&lt; &gt;&gt;
     when this happens
     the ; must NOT be readed
   * note that
     a bar-ket is readed as a word
     double-quote is special bar-ket
     but "&lt;" &amp; "&gt;" are not viewed as bar-ket
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   buffer$colon <span class="keyword">labeling</span>
      <span class="type">preserve</span> <span class="constant">1024</span> * <span class="constant">1024</span>

   <span class="function-name">cursor$colon</span>:
      <span class="type">xx</span> <span class="constant">0</span>


   define_function <span class="string">":"</span>, colon
      <span class="comment">;; &lt;&lt; -- string[address of buffer$colon, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$colon
      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, save
      <span class="type">xx</span> help__loop__colon
      <span class="comment">;; address
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$colon
      <span class="comment">;; length
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, buffer$colon
      <span class="type">xx</span> subtraction
      <span class="type">xx</span> <span class="keyword">end</span>


   define_function <span class="string">""</span>, help__loop__colon
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> read_byte
      <span class="type">xx</span> help__save_byte__colon
      <span class="type">xx</span> help__meet_end__colon?, <span class="keyword">false?branch</span>, <span class="constant">7</span>
      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="constant">3</span> <span class="comment">;; for the string " ; "
</span>      <span class="type">xx</span>   <span class="keyword">literal</span>, cursor$colon
      <span class="type">xx</span>   sub_save
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> help__meet_comment__colon?, <span class="keyword">false?branch</span>, <span class="constant">9</span>
      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="constant">4</span> <span class="comment">;; for the string " &lt;&lt; "
</span>      <span class="type">xx</span>   <span class="keyword">literal</span>, cursor$colon
      <span class="type">xx</span>   sub_save
      <span class="type">xx</span>   ignore_comment
      <span class="type">xx</span>   <span class="keyword">taca</span>, help__loop__colon
      <span class="type">xx</span> <span class="keyword">taca</span>, help__loop__colon


   define_function <span class="string">""</span>, help__save_byte__colon
      <span class="comment">;; &lt;&lt; byte -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> save_byte
      <span class="type">xx</span> one
      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon
      <span class="type">xx</span> add_save
      <span class="type">xx</span> <span class="keyword">end</span>


   define_function <span class="string">""</span>, help__meet_end__colon?
      <span class="comment">;; &lt;&lt; -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">3</span>, subtraction
      <span class="type">xx</span> fetch_byte, space_char?
      <span class="type">xx</span> false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">2</span>, subtraction
      <span class="type">xx</span> fetch_byte, <span class="keyword">literal</span>, <span class="default">';'</span>, equal?
      <span class="type">xx</span> false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">1</span>, subtraction
      <span class="type">xx</span> fetch_byte, space_char?
      <span class="type">xx</span> false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> true
      <span class="type">xx</span> <span class="keyword">end</span>

   define_function <span class="string">""</span>, help__meet_comment__colon?
      <span class="comment">;; &lt;&lt; -- bool &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">4</span>, subtraction
      <span class="type">xx</span> fetch_byte, space_char?
      <span class="type">xx</span> false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">3</span>, subtraction
      <span class="type">xx</span> fetch_byte, <span class="keyword">literal</span>, <span class="default">'&lt;'</span>, equal?
      <span class="type">xx</span> false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">2</span>, subtraction
      <span class="type">xx</span> fetch_byte, <span class="keyword">literal</span>, <span class="default">'&lt;'</span>, equal?
      <span class="type">xx</span> false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> <span class="keyword">literal</span>, cursor$colon, fetch
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">1</span>, subtraction
      <span class="type">xx</span> fetch_byte, space_char?
      <span class="type">xx</span> false?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   false
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> true
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ignore-comment</span>
   * this function is for basic-REPL
     but it is reused by colon
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"&lt;&lt;"</span>, ignore_comment
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> read_word
      <span class="type">xx</span> dup2, comment_begin_string?, <span class="keyword">false?branch</span>, <span class="constant">5</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>     ignore_comment <span class="comment">;; for the new nested-comment
</span>      <span class="type">xx</span>   <span class="keyword">taca</span>, ignore_comment <span class="comment">;; for the rest-comment
</span>      <span class="type">xx</span> dup2, comment_end_string?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> drop2
      <span class="type">xx</span> <span class="keyword">taca</span>, ignore_comment
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src cicada-nymph
</span>   <span class="cicada-nymph-number">1</span> <span class="cicada-nymph-comment">&lt;&lt; 989 &gt;&gt;</span> <span class="cicada-nymph-number">64</span> add .
   <span class="cicada-nymph-comment">&lt;&lt; 65 &gt;&gt;</span>

   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">kkk</span> <span class="cicada-nymph-comment">&lt;&lt; 989 &lt;&lt; 989 &gt;&gt;</span> &gt;&gt; <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">.s</span>
   <span class="cicada-nymph-comment">&lt;&lt; kkk &gt;&gt;</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-1">* function &amp; jojo</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** memory allocation</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   size$jo_heap = <span class="constant">3</span> * <span class="constant">1024</span> * <span class="constant">1024</span> * jo_size

   define_variable <span class="string">"*jo-heap*"</span>, V__jo_heap
     <span class="type">xx</span> address$jo_heap

   define_variable <span class="string">"*size,jo-heap*"</span>, V__size__jo_heap
     <span class="type">xx</span> size$jo_heap


   address$jo_heap <span class="keyword">labeling</span>
      <span class="type">preserve</span> size$jo_heap

   define_variable <span class="string">"*current-free-address,jo-heap*"</span>, V__current_free_address__jo_heap
      <span class="type">xx</span> address$jo_heap
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * the make-jojo is a macro dispatcher
     it can be viewed as make-function-body
     it gets next word and use predicates on word to do dispatch
   * note that
     make-jojo can be viewed as the "compiler" of the cicada-nymph
     it does NOT (can not) compile file to file
     but creates structured data directly into memory
<span class="org-level-2">** !undo-make-jojo</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_exception <span class="string">"!undo-make-jojo"</span>, !undo_make_jojo
      <span class="comment">;; &lt;&lt; old V__current_free_address__primitive_string
</span>      <span class="comment">;;    old V__current_free_address__jo_heap
</span>      <span class="comment">;;    old V__first_jo_in_dictionary
</span>      <span class="comment">;;    string[address, length]
</span>      <span class="comment">;;    -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$undo_make_jojo_report
      <span class="type">xx</span> <span class="keyword">literal</span>, length$undo_make_jojo_report
      <span class="type">xx</span> write_string

      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>, write_byte
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="default">';'</span>, write_byte
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>, write_byte

      <span class="type">xx</span> <span class="keyword">address</span>, V__first_jo_in_dictionary, save
      <span class="type">xx</span> <span class="keyword">address</span>, V__current_free_address__jo_heap, save
      <span class="type">xx</span> <span class="keyword">address</span>, V__current_free_address__primitive_string
      <span class="type">xx</span> save
      <span class="type">xx</span> <span class="keyword">end</span>


   <span class="function-name">string$undo_make_jojo_report</span>:
      <span class="type">db</span> <span class="string">"  THE FOLLOWING JOJO IS NOT MADE :"</span>
      <span class="type">db</span> <span class="constant">10</span>
      <span class="type">db</span> <span class="string">": "</span>
   <span class="function-name">.end</span>:
   length$undo_make_jojo_report = (.end - string$undo_make_jojo_report)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** make-jojo</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"make-jojo"</span>, make_jojo
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> dup2, space_string?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   drop2
      <span class="type">xx</span>   <span class="keyword">end</span>
      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_tail__word
      <span class="type">xx</span> xxswapxx
      <span class="type">xx</span> string_head__word
      <span class="comment">;; &lt;&lt; tail[address, length], head[address, length] &gt;&gt;
</span>      <span class="type">xx</span> make_jojo__dispatch_word
      <span class="type">xx</span> <span class="keyword">taca</span>, make_jojo

   define_function <span class="string">"make-jojo,dispatch-word"</span>, make_jojo__dispatch_word
      <span class="comment">;; &lt;&lt; string[address, length], word[address, length] --
</span>      <span class="comment">;;    string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> dup2, integer_string?, <span class="keyword">false?branch</span>, <span class="constant">7</span>
      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="keyword">literal</span>
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   string_to_integer
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>     <span class="keyword">end</span>
      <span class="type">xx</span> dup2
      <span class="type">xx</span> find, false?
      <span class="type">xx</span> <span class="keyword">false?branch</span>, <span class="constant">7</span>
      <span class="type">xx</span>   write_undefined_word_report__for_make_jojo
      <span class="type">xx</span>   write_string
      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="constant">10</span>, write_byte
      <span class="type">xx</span>   !undo_make_jojo
      <span class="type">xx</span> xxswapx, drop2 <span class="comment">;; word
</span>      <span class="type">xx</span> <span class="keyword">taca</span>, make_jojo__dispatch_jo

   define_function <span class="string">"make-jojo,dispatch-jo"</span>, make_jojo__dispatch_jo
      <span class="comment">;; &lt;&lt; string[address, length], jo --
</span>      <span class="comment">;;    string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, macro_jo?, <span class="keyword">false?branch</span>, <span class="constant">3</span>
      <span class="type">xx</span>   execute_jo
      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="comment">;; the same to
</span>      <span class="comment">;;   function
</span>      <span class="comment">;;   primitive-function
</span>      <span class="comment">;;   variable
</span>      <span class="comment">;;   exception
</span>      <span class="type">xx</span> save_into__jo_heap
      <span class="type">xx</span> <span class="keyword">end</span>


   define_function <span class="string">"write-undefined-word-report,for-make-jojo"</span>, write_undefined_word_report__for_make_jojo
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$undefined_word_report__for_make_jojo
      <span class="type">xx</span> <span class="keyword">literal</span>, length$undefined_word_report__for_make_jojo
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>

   <span class="function-name">string$undefined_word_report__for_make_jojo</span>:
      <span class="type">db</span> <span class="string">"* (make-jojo) MEETS UNDEFINED WORD : "</span>
   <span class="function-name">.end</span>:
   length$undefined_word_report__for_make_jojo = (.end - string$undefined_word_report__for_make_jojo)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span><span class="org-level-2"> macro in cicada-nymph</span>
   * a macro is a function to be called at compile time
     with a string to be compiled as one argument
     and do side-effect to store data into memory
     and return a shorter string
     [this can be viewed as moving a cursor forward]
   * a macro should be highlight by text editor in a special way
<span class="org-level-2">** address</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_macro <span class="string">"address"</span>, M__address
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="keyword">address</span>
      <span class="type">xx</span> save_into__jo_heap

      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_head__word
      <span class="type">xx</span> find, <span class="keyword">false?branch</span>, <span class="constant">4</span>
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span>   string_tail__word
      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="type">xx</span> write_undefined_word_report__for_address
      <span class="type">xx</span> dup2, string_head__word, write_string
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>, write_byte
      <span class="type">xx</span> !undo_make_jojo


   define_function <span class="string">"write-undefined-word-report,for-address"</span>, write_undefined_word_report__for_address
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$undefined_word_report__for_address
      <span class="type">xx</span> <span class="keyword">literal</span>, length$undefined_word_report__for_address
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>

   <span class="function-name">string$undefined_word_report__for_address</span>:
      <span class="type">db</span> <span class="string">"* (make-jojo (address)) THE WORD FOLLOWS (address) IS UNDEFINED : "</span>
   <span class="function-name">.end</span>:
   length$undefined_word_report__for_address = (.end - string$undefined_word_report__for_address)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** branch</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_macro <span class="string">"branch"</span>, M__branch
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="keyword">branch</span>
      <span class="type">xx</span> save_into__jo_heap

      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_head__word
      <span class="type">xx</span> dup2, integer_string?, <span class="keyword">false?branch</span>, <span class="constant">5</span>
      <span class="type">xx</span>   string_to_integer
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span>   string_tail__word
      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="type">xx</span> write_not_integer_string_report__for_branch
      <span class="type">xx</span> dup2, string_head__word, write_string
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>, write_byte
      <span class="type">xx</span> !undo_make_jojo


   define_function <span class="string">"write-not-integer-string-report,for-branch"</span>, write_not_integer_string_report__for_branch
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$not_integer_string_report__for_branch
      <span class="type">xx</span> <span class="keyword">literal</span>, length$not_integer_string_report__for_branch
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>

   <span class="function-name">string$not_integer_string_report__for_branch</span>:
      <span class="type">db</span> <span class="string">"* (make-jojo (branch)) THE WORD FOLLOWS (branch) MUST BE A INTEGER STRING : "</span>
   <span class="function-name">.end</span>:
   length$not_integer_string_report__for_branch = (.end - string$not_integer_string_report__for_branch)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** false?branch</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_macro <span class="string">"false?branch"</span>, M__false?branch
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="keyword">false?branch</span>
      <span class="type">xx</span> save_into__jo_heap

      <span class="type">xx</span> dup2
      <span class="type">xx</span> string_head__word
      <span class="type">xx</span> dup2, integer_string?, <span class="keyword">false?branch</span>, <span class="constant">5</span>
      <span class="type">xx</span>   string_to_integer
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span>   string_tail__word
      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="type">xx</span> write_not_integer_string_report__for_false?branch
      <span class="type">xx</span> dup2, string_head__word, write_string
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>, write_byte
      <span class="type">xx</span> !undo_make_jojo


   define_function <span class="string">"write-not-integer-string-report,for-false?branch"</span>, write_not_integer_string_report__for_false?branch
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$not_integer_string_report__for_false?branch
      <span class="type">xx</span> <span class="keyword">literal</span>, length$not_integer_string_report__for_false?branch
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>

   <span class="function-name">string$not_integer_string_report__for_false?branch</span>:
      <span class="type">db</span> <span class="string">"* (make-jojo (false?branch)) THE WORD FOLLOWS (false?branch) MUST BE A INTEGER STRING : "</span>
   <span class="function-name">.end</span>:
   length$not_integer_string_report__for_false?branch = (.end - string$not_integer_string_report__for_false?branch)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** double-quote</span>
   * primitive-string-heap is used
     to allocate string literal in function body
   * in ASCII encode double-quote is 34
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_macro <span class="default">'"'</span>, M__double_quote
      <span class="comment">;; &lt;&lt; string[address, length] -- string[address, length] &gt;&gt;
</span>      <span class="type">xx</span> dup2
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="default">'"'</span>, find_char__string
      <span class="type">xx</span> <span class="keyword">false?branch</span>, (.not_found-$)/jo_size
      <span class="type">xx</span>   xoverxx, subtraction
      <span class="comment">;;   &lt;&lt; string[address, length], length &gt;&gt;
</span>
      <span class="comment">;; address
</span>      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="keyword">literal</span>
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   V__current_free_address__primitive_string, add2
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   xoverxx, over
      <span class="type">xx</span>     save_into__primitive_string_heap

      <span class="comment">;; length
</span>      <span class="type">xx</span>   <span class="keyword">literal</span>, <span class="keyword">literal</span>
      <span class="type">xx</span>     save_into__jo_heap
      <span class="type">xx</span>   <span class="keyword">dup</span>
      <span class="type">xx</span>     save_into__jo_heap

      <span class="type">xx</span>   tuck, subtraction
      <span class="type">xx</span>   xxswapx
      <span class="type">xx</span>   addition
      <span class="type">xx</span>   swap

      <span class="type">xx</span>   string_tail__char <span class="comment">;; over the ending double-quote
</span>      <span class="type">xx</span>   <span class="keyword">end</span>

      <span class="function-name">.not_found</span>:
      <span class="type">xx</span> write_not_integer_string_report__for_double_quote
      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">10</span>, write_byte
      <span class="type">xx</span> !undo_make_jojo


   define_function <span class="string">"write-not-integer-string-report,for-double-quote"</span>, write_not_integer_string_report__for_double_quote
      <span class="comment">;; &lt;&lt; -- &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">literal</span>, string$not_integer_string_report__for_double_quote
      <span class="type">xx</span> <span class="keyword">literal</span>, length$not_integer_string_report__for_double_quote
      <span class="type">xx</span> write_string
      <span class="type">xx</span> <span class="keyword">end</span>

   <span class="function-name">string$not_integer_string_report__for_double_quote</span>:
      <span class="type">db</span> <span class="string">"* (make-jojo (double-quote)) CAN NOT FIND THE ENDING DOUBLE-QUOTE"</span>
   <span class="function-name">.end</span>:
   length$not_integer_string_report__for_double_quote = (.end - string$not_integer_string_report__for_double_quote)
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * for the following function
     I add the "CICADA__" as prefix
     to distinguish from their assembly code version
<span class="org-level-2">** define-function</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"define-function"</span>, CICADA__define_function
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> V__current_free_address__primitive_string, xxswapx
      <span class="type">xx</span> V__current_free_address__jo_heap, xxswapx
      <span class="type">xx</span> V__first_jo_in_dictionary, xxswapx
      <span class="type">xx</span> prepare_for
      <span class="type">xx</span>   exception_head
      <span class="type">xx</span>   !undo_make_jojo
      <span class="type">xx</span>   end_of_prepare


      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> dup2, string_head__word
      <span class="type">xx</span>   save_into__primitive_string_heap

      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> <span class="keyword">address</span>, V__first_jo_in_dictionary
      <span class="type">xx</span> save

      <span class="type">xx</span> <span class="keyword">literal</span>, explain$function
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> dup2, string_tail__word
      <span class="type">xx</span>   make_jojo


      <span class="type">xx</span> drop2
      <span class="type">xx</span> drop, drop, drop
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src cicada-nymph
</span>   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">addadd</span> add add <span class="cicada-nymph-end">end</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> <span class="cicada-nymph-number">2</span> <span class="cicada-nymph-number">3</span> addadd . <span class="cicada-nymph-comment">&lt;&lt; 6 &gt;&gt;</span>

   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">add1</span> <span class="cicada-nymph-number">1</span> add <span class="cicada-nymph-end">end</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> add1 . <span class="cicada-nymph-comment">&lt;&lt; 2 &gt;&gt;</span>

   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">negate</span> <span class="cicada-nymph-number">0</span> swap sub <span class="cicada-nymph-end">end</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> negate . <span class="cicada-nymph-comment">&lt;&lt; -1 &gt;&gt;</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** define-macro</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"define-macro"</span>, CICADA__define_macro
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> V__current_free_address__primitive_string, xxswapx
      <span class="type">xx</span> V__current_free_address__jo_heap, xxswapx
      <span class="type">xx</span> V__first_jo_in_dictionary, xxswapx
      <span class="type">xx</span> prepare_for
      <span class="type">xx</span>   exception_head
      <span class="type">xx</span>   !undo_make_jojo
      <span class="type">xx</span>   end_of_prepare


      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> dup2, string_head__word
      <span class="type">xx</span>   save_into__primitive_string_heap

      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> <span class="keyword">address</span>, V__first_jo_in_dictionary
      <span class="type">xx</span> save

      <span class="type">xx</span> <span class="keyword">literal</span>, explain$macro
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> dup2, string_tail__word
      <span class="type">xx</span>   make_jojo


      <span class="type">xx</span> drop2
      <span class="type">xx</span> drop, drop, drop
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** define-exception</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"define-exception"</span>, CICADA__define_exception
      <span class="comment">;; &lt;&lt; string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> V__current_free_address__primitive_string, xxswapx
      <span class="type">xx</span> V__current_free_address__jo_heap, xxswapx
      <span class="type">xx</span> V__first_jo_in_dictionary, xxswapx
      <span class="type">xx</span> prepare_for
      <span class="type">xx</span>   exception_head
      <span class="type">xx</span>   !undo_make_jojo
      <span class="type">xx</span>   end_of_prepare


      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> dup2, string_head__word
      <span class="type">xx</span>   save_into__primitive_string_heap

      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> <span class="keyword">address</span>, V__first_jo_in_dictionary
      <span class="type">xx</span> save

      <span class="type">xx</span> <span class="keyword">literal</span>, explain$exception
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> dup2, string_tail__word
      <span class="type">xx</span>   make_jojo


      <span class="type">xx</span> drop2
      <span class="type">xx</span> drop, drop, drop
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * not undo is needed for define-variable
<span class="org-level-2">** define-variable</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"define-variable"</span>, CICADA__define_variable
      <span class="comment">;; &lt;&lt; variable, string[address, length] -- &gt;&gt;
</span>      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span>   save_into__jo_heap
      <span class="type">xx</span> dup2, string_head__word
      <span class="type">xx</span>   save_into__primitive_string_heap

      <span class="type">xx</span> V__first_jo_in_dictionary
      <span class="type">xx</span> jo_to_link
      <span class="type">xx</span>   save_into__jo_heap

      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> <span class="keyword">address</span>, V__first_jo_in_dictionary
      <span class="type">xx</span> save

      <span class="type">xx</span> <span class="keyword">literal</span>, explain$variable
      <span class="type">xx</span>   save_into__jo_heap

      <span class="comment">;; when debugging
</span>      <span class="comment">;; instead of drop2
</span>      <span class="comment">;; one may wish to do some thing to the string
</span>      <span class="type">xx</span> drop2
      <span class="type">xx</span> save_into__jo_heap
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-todo">note</span>
   * you can see how the naming convention is used
     for functions that create structured data into memory
<span class="org-level-2">** save-into,primitive-string-heap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"save-into,primitive-string-heap"</span>, save_into__primitive_string_heap
      <span class="comment">;; &lt;&lt; string[address, length] -- address &gt;&gt;
</span>      <span class="type">xx</span> <span class="keyword">dup</span>, V__current_free_address__primitive_string
      <span class="type">xx</span> save_two_bytes

      <span class="type">xx</span> <span class="keyword">literal</span>, <span class="constant">2</span>
      <span class="type">xx</span> <span class="keyword">address</span>, V__current_free_address__primitive_string
      <span class="type">xx</span> add_save

      <span class="type">xx</span> tuck
      <span class="type">xx</span> V__current_free_address__primitive_string
      <span class="type">xx</span> string_to_buffer!

      <span class="type">xx</span> <span class="keyword">address</span>, V__current_free_address__primitive_string
      <span class="type">xx</span> add_save
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** save-into,jo-heap</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_function <span class="string">"save-into,jo-heap"</span>, save_into__jo_heap
      <span class="comment">;; &lt;&lt; number -- address &gt;&gt;
</span>      <span class="type">xx</span> V__current_free_address__jo_heap
      <span class="type">xx</span> save

      <span class="type">xx</span> <span class="keyword">literal</span>, jo_size
      <span class="type">xx</span> <span class="keyword">address</span>, V__current_free_address__jo_heap
      <span class="type">xx</span> add_save
      <span class="type">xx</span> <span class="keyword">end</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-done">test</span>
<span class="org-block-begin-line">   #+begin_src cicada-nymph
</span>   <span class="cicada-nymph-number">233</span> <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">*three*</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-variable</span>
   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">add-three</span> <span class="cicada-nymph-variable">*three*</span> add <span class="cicada-nymph-end">end</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   <span class="cicada-nymph-number">1</span> add-three . <span class="cicada-nymph-comment">&lt;&lt; 234 &gt;&gt;</span>

   <span class="cicada-nymph-comment">&lt;&lt; you get the address of the variable *three*
      by add "address" in front of it &gt;&gt;</span>
   <span class="cicada-nymph-sentence-reader">:</span> <span class="cicada-nymph-word-to-define">fix-*three*</span> <span class="cicada-nymph-number">3</span> <span class="cicada-nymph-syntax-key-word">address</span> <span class="cicada-nymph-variable">*three*</span> save <span class="cicada-nymph-end">end</span> <span class="cicada-nymph-sentence-reader">;</span> <span class="cicada-nymph-lexicographer">define-function</span>
   fix-*three*
   <span class="cicada-nymph-number">1</span> add-three . <span class="cicada-nymph-comment">&lt;&lt; 4 &gt;&gt;</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* -----------------------------------</span>
<span class="org-level-1">* epilog</span>
<span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-level-2"><span class="bold">*un-initialized-memory*</span></span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*un-initialized-memory*"</span>, V__un_initialized_memory
     <span class="type">xx</span> address$un_initialized_memory

   define_variable <span class="string">"*size,un-initialized-memory*"</span>, V__size__un_initialized_memory
     <span class="type">xx</span> size$un_initialized_memory

   define_variable <span class="string">"*current-free-address,un-initialized-memory*"</span>, V__current_free_address__un_initialized_memory
     <span class="type">xx</span> current_free_address$un_initialized_memory
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** </span><span class="org-level-2"><span class="bold">*current-free-address,primitive-string-heap*</span></span>
   * the last_primitive_string_in_assembly
     is just "<span class="bold">*current-free-address,primitive-string-heap*</span>"
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   define_variable <span class="string">"*current-free-address,primitive-string-heap*"</span>, V__current_free_address__primitive_string
      <span class="type">xx</span> current_free_address$primitive_string_heap
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** last_link</span>
   * this word helps to initialize V__first_jo_in_dictionary
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   last_link = link
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** un_initialized_memory [linux64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =linux =64bit, platform machine {


   size$un_initialized_memory = <span class="constant">64</span> * <span class="constant">1024</span> * <span class="constant">1024</span> <span class="comment">;; (byte)
</span>
   <span class="keyword">segment</span> <span class="keyword">readable</span> <span class="keyword">writeable</span>
   <span class="function-name">address$un_initialized_memory</span>:
      <span class="type">rb</span> size$un_initialized_memory


      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-2">** un_initialized_memory [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {


   size$un_initialized_memory = <span class="constant">64</span> * <span class="constant">1024</span> * <span class="constant">1024</span> <span class="comment">;; (byte)
</span>
   <span class="keyword">section</span> <span class="default">'.data'</span> <span class="keyword">data</span> <span class="keyword">readable</span> <span class="keyword">writeable</span>
   <span class="function-name">address$un_initialized_memory</span>:
      <span class="type">rb</span> size$un_initialized_memory


      }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** macro about import [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="keyword">if</span> platform <span class="keyword">eq</span> windows
   <span class="keyword">if</span> machine <span class="keyword">eq</span> 64bit


   <span class="comment">;; Macroinstructions for making import section (64-bit)
</span>
   <span class="preprocessor">macro</span> <span class="function-name">library</span> [name,string]
    { <span class="preprocessor">common</span>
       <span class="function-name">import.data</span>:
      <span class="preprocessor">forward</span>
       <span class="preprocessor">local</span> _label
       <span class="keyword">if</span> <span class="keyword">defined</span> name#.redundant
        <span class="keyword">if</span> ~ name#.redundant
         <span class="type">dd</span> <span class="keyword">RVA</span> name#.lookup,<span class="constant">0</span>,<span class="constant">0</span>,<span class="keyword">RVA</span> _label,<span class="keyword">RVA</span> name#.address
        <span class="keyword">finish</span> <span class="keyword">if</span>
       <span class="keyword">finish</span> <span class="keyword">if</span>
       name#.referred = <span class="constant">1</span>
      <span class="preprocessor">common</span>
       <span class="type">dd</span> <span class="constant">0</span>,<span class="constant">0</span>,<span class="constant">0</span>,<span class="constant">0</span>,<span class="constant">0</span>
      <span class="preprocessor">forward</span>
       <span class="keyword">if</span> <span class="keyword">defined</span> name#.redundant
        <span class="keyword">if</span> ~ name#.redundant
         _label <span class="type">db</span> string,<span class="constant">0</span>
                <span class="type">rb</span> <span class="keyword">RVA</span> $ <span class="builtin">and</span> <span class="constant">1</span>
        <span class="keyword">finish</span> <span class="keyword">if</span>
       <span class="keyword">finish</span> <span class="keyword">if</span> }

   <span class="preprocessor">macro</span> <span class="keyword">import</span> name,[<span class="keyword">label</span>,string]
    { <span class="preprocessor">common</span>
       <span class="type">rb</span> (- <span class="keyword">rva</span> $) <span class="builtin">and</span> <span class="constant">7</span>
       <span class="keyword">if</span> <span class="keyword">defined</span> name#.referred
        name#.lookup:
      <span class="preprocessor">forward</span>
        <span class="keyword">if</span> <span class="keyword">used</span> <span class="keyword">label</span>
         <span class="keyword">if</span> string <span class="keyword">eqtype</span> <span class="default">''</span>
          <span class="preprocessor">local</span> _label
          <span class="type">dq</span> <span class="keyword">RVA</span> _label
         <span class="keyword">else</span>
          <span class="type">dq</span> <span class="constant">8000000000000000h</span> + string
         <span class="keyword">finish</span> <span class="keyword">if</span>
        <span class="keyword">finish</span> <span class="keyword">if</span>
      <span class="preprocessor">common</span>
        <span class="keyword">if</span> $ &gt; name#.lookup
         name#.redundant = <span class="constant">0</span>
         <span class="type">dq</span> <span class="constant">0</span>
        <span class="keyword">else</span>
         name#.redundant = <span class="constant">1</span>
        <span class="keyword">finish</span> <span class="keyword">if</span>
        name#.address:
      <span class="preprocessor">forward</span>
        <span class="keyword">if</span> <span class="keyword">used</span> <span class="keyword">label</span>
         <span class="keyword">if</span> string <span class="keyword">eqtype</span> <span class="default">''</span>
          <span class="keyword">label</span> <span class="type">dq</span> <span class="keyword">RVA</span> _label
         <span class="keyword">else</span>
          <span class="keyword">label</span> <span class="type">dq</span> <span class="constant">8000000000000000h</span> + string
         <span class="keyword">finish</span> <span class="keyword">if</span>
        <span class="keyword">finish</span> <span class="keyword">if</span>
      <span class="preprocessor">common</span>
        <span class="keyword">if</span> ~ name#.redundant
         <span class="type">dq</span> <span class="constant">0</span>
        <span class="keyword">finish</span> <span class="keyword">if</span>
      <span class="preprocessor">forward</span>
        <span class="keyword">if</span> <span class="keyword">used</span> <span class="keyword">label</span> &amp; string <span class="keyword">eqtype</span> <span class="default">''</span>
        _label <span class="type">dw</span> <span class="constant">0</span>
               <span class="type">db</span> string,<span class="constant">0</span>
               <span class="type">rb</span> <span class="keyword">RVA</span> $ <span class="builtin">and</span> <span class="constant">1</span>
        <span class="keyword">finish</span> <span class="keyword">if</span>
      <span class="preprocessor">common</span>
       <span class="keyword">finish</span> <span class="keyword">if</span> }


   <span class="keyword">finish</span> <span class="keyword">if</span>
   <span class="keyword">finish</span> <span class="keyword">if</span>
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** section about import [windows64]</span>
<span class="org-block-begin-line">   #+begin_src fasm :tangle cicada-nymph.fasm
</span>   <span class="preprocessor">match</span> =windows =64bit, platform machine {


   <span class="keyword">section</span> <span class="default">'.idata'</span> <span class="keyword">import</span> <span class="keyword">data</span> <span class="keyword">readable</span> <span class="keyword">writeable</span>

   library kernel32,<span class="default">'KERNEL32.DLL'</span>

   <span class="keyword">import</span> kernel32,\
          ExitProcess,<span class="default">'ExitProcess'</span>,\
          ReadFile,<span class="default">'ReadFile'</span>,\
          WriteFile,<span class="default">'WriteFile'</span>,\
          GetStdHandle,<span class="default">'GetStdHandle'</span>


       }
<span class="org-block-end-line">   #+end_src
</span><span class="org-level-2">** ----------------------------------</span>
<span class="org-level-1">* ===================================</span>
</pre>
  </body>
</html>
