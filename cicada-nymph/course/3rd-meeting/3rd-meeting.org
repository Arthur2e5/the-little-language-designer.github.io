#+TITLE:  第三次見面 / 3rd-meeting
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
  * 在生成的 html 中手動添加圖片
    做一些 模板 來幫助添加圖片
* ===================================
* 線串碼解釋器
** 題解
   * 線串碼解釋器[threaded code interpreter]
     常被 Forth 程序員稱作是內部解釋器[inner interpreter]
   * "thread" 做名詞有線程意思
     而 "threaded" 在這裏是動詞
     意思是 "穿針" 的 "穿"
     而 "threaded code" 就是 "被線穿起來的一串代碼" 的意思
     ><><>< [圖片]
   * 我用 珠[jo] 來 比如 "線串碼" 中的 "碼"
     "一串碼" 就是 一串珠子[珠珠][jojo]
* -----------------------------------
* *抽象的理論*
  * 抽象的理論並不針對匯編語言
    用任何程序語言都可以實現這裏所描述的 線串碼解釋器
* 珠珠
** 珠子能被穿成串
   * 比如下面是三顆珠子穿成的一串珠子
     #+begin_src return-stack
        (dup)
        (multiple)
        (end)
     #+end_src
     它所記錄的三個操作
     能夠用來計算一個數的平方
   * 函數的複合就是把兩個函數相機作用
     所以 穿珠子的過程就像是製作複合函數的過程
     所以 一串珠子就代表一個函數[複合函數]的函數體
** 有一串珠子 那麼可以製作一個新珠子 來代表這一串珠子
   * 給以 函數的複合所形成的 函數體[一串珠子] 一個名字
     就是用舊的函數定義新函數[一個新珠子]的過程
   * 一顆珠子代表一個函數
     一串珠子代表一些函數的複合做形成的函數體
     一個函數體可以被給以名字
     而定義爲一個新的函數
** 對應關係的建立過程就像是撰寫詞典
   * 被對應的二者分別是
     1. 代表函數體的 那一串珠子
     2. 代表新定義的函數的 那一粒新珠子
     建立這種對應關係的方式是
     去編撰一本 "珠子的詞典" 來記錄其關係
   * 每添加一個新的條目進去
     就形成了一個新的對應關係
     #+begin_src return-stack
     例如 一顆珠子
     (square)
     對應於詞典中的一個詞條
     而 一串珠子
          (dup)
          (multiple)
          (end)
     對應於對這個詞條的解釋
     #+end_src
** 珠子的詞典
   * 在一本詞典中
     你可以通過一個詞的頁碼和行數[即詞的地址]
     找到這個詞條 然後查閱其內容
   * 在我們的 珠子的詞典 中也是一樣
     每個被定義到詞典中的珠子也有一個地址
     ><><>< [圖片]
** 具體應該如何想像一粒珠子呢
*** 首先要知道
    * 珠子上的需要記錄一些信息
      但是珠子上的位置有限
      把字符串刻在珠子上 是刻不下的
*** 然而
    * 既然每個珠子都是在珠子的詞典中有記錄的
      只要找到了一個珠子在詞典中的位置
      那麼
      代表這個珠子名字的字符串
      還有
      用來定義這個珠子的一串珠子
      就都能找到了
*** 所以
    * 我們不必把珠子的名字刻在珠子上
      只要把它在詞典中的地址刻在珠子上就行了
      所以一個珠子上其實是一個數字
      這個數字是珠子的詞典中的一個地址
** 珠子的分類
   * 素函數珠 [primitive-function-jo]
   * 函數珠   [function-jo]
   * 變量珠   [variable-jo]
** 素性
   * 其中
     素函數珠 就像是 素數 一樣
     是不能再被分解爲其他珠子的
   * 然而
     其他的 函數珠 則可以再分解
     #+begin_src return-stack
     比如 (square)
     可以被分解成
          (dup)
          (multiple)
     而 (end) 只是用來標記一串珠子的結束而已
     並不算是分解出來的成分
     #+end_src
* 棧
** 一摞東西
   * 啥東西都行
** 這摞東西的特點是
   * 放在下面[或前面]東西
     必須等放在上面[或後面]東西
     都被拿走之後
     才能被拿走
* 利用兩個棧來形成函數語義
** 參數棧與返回棧
   * 參數棧 [argument-stack]
   * 返回棧 [return-stack]
** 參數傳遞
   * 利用 參數棧
   * 你可以想像每個 素函數珠
     能夠幫你召喚出一個小機器人[或者小精靈]
     來爲你做一些計算和操作
   * 計算的材料都要從 參數棧 中取 [即函數的參數]
     並且計算的結果也要返回 棧參數 中 [即函數的返回值]
     #+begin_src return-stack
     比如 (multiple) 是一個 素函數珠
       它召喚出來一個小精靈 幫你做乘法
     而 (dup) 也是一個 素函數珠
       它召喚出來一個小精靈 來把 參數棧 頂部的數複製一下
     但是 (square) 則不是 素函數珠
       因爲它是被分解成上面的兩個 素函數 的複合的
     #+end_src
   * 這樣 參數棧 就成了 小精靈們 傳遞計算結果的場所
     一個 小精靈 計算成果
     可以被作爲 另一個 小精靈 的參數
** 函數的 嵌套定義 與 嵌套調用
   * 利用 返回棧
   * 珠子的串 是一個 可以嵌套的數據結構
     因爲一串珠子中的每個 函數珠 本身又對應 一串珠子
   * 而處理 嵌套的數據結構 需要用 遞歸函數
     而實現 遞歸函數 需要用棧
   * 詮釋者 展開遞歸函數
     線串碼解釋器的 "next" 指令用來 收斂遞歸函數
* -----------------------------------
* *具體的實現*
  * 具體在匯編語言中
    來實現上面所描述的 抽象的 線串碼解釋器
* 具體的構架
** 回憶費恩曼的比喻
   |----------------------+--------------------|
   | 能比                 | 所比               |
   |----------------------+--------------------|
   | 檔案館               | 一級存儲器 (內存)  |
   | 黑板                 | 中央處理器的寄存器 |
   | 檔案館員工一名       | 中央處理器 (CPU)   |
   | 檔案館員工的基本素養 | 處理器的指令集     |
   |----------------------+--------------------|
* 具體計算機構架 之 x86 篇
** 32bit 與 64bit
   * CPU 的寄存器的大小
     [基本數學運算所能處理的數字的大小]
   * 內存 的地址範圍
     [CPU 的尋址能力]
     [地址總線的寬度]
** 利慾薰心者引發的災難
   * 三個模式
     |-------+--------------|
     | 16bit | real-mode    |
     | 32bit | protect-mode |
     | 64bit | long-mode    |
     |-------+--------------|
   * 當設 CPU 從 16bit 升級到 32bit
     CPU 必須保持能夠運行 16bit 的老程序的能力
     這種設計被成爲 "向後兼容"
     "向後兼容"
     1. 不利於 CPU 的設計師把 CPU 設計好
        比如
        若不考慮 "向後兼容" 的問題
        32bit 的 CPU 就可以設計得更加優雅和精簡
     2. 不利於 編碼者給 CPU 寫程序
        因爲複雜而不易學習與理解
     3. 有利於 CPU 公司 和 軟件公司 的短期利潤率
        買了新硬件的人 也可能買老程序
        買了老程序的人 也更願意買新硬件
   * 這是典型的
     因利慾薰心 而目光短淺
     因目光短淺 而作出壞的決策
     而壞的決策的積累 而產生了災難性的後果
   * 三個模式的產生
     只是這種災難的一方面而已
** 檔案館
   * 32bit

   -------------------------
   * 64bit
** 黑板
   * 32bit

   -------------------------
   * 64bit

** 檔案館員工一名
   * 先考慮給單個 CPU 編程
** 檔案館員工的基本素養
* 說明代碼結構
  * 首先是前言
    1. 對匯編器原本的語法做一些調整
    2. 跟構架相關的全局變量
    3. 操作系統相關
       1) 系統調用的參數順序
          系統調用相關的全局變量
       2) 可執行文件格式的指定
       3) 程序執行點的指定
  * 參數棧與返回棧
  * next 是對返回棧的操作
    它形成了函數調用語義
  * 最後是尾聲
    1.
    2.
    3.
* 匯編語言中製作棧
* 珠珠之數據結構
* -----------------------------------
* 資料
** OSdev [社區]
   * 一羣設計新的操作系統的人所做成的社區
     有非常好的 [[http://forum.osdev.org/][維基]] 和 [[http://forum.osdev.org/][論壇]]
* ===================================
